# PLAN: Jarvis Comprehensive UX Refactor
Date: 2026-02-25
Status: Draft
Updated: 2026-02-26 (expanded scope for full customization)

## REQUIRED SKILLS - LOAD BEFORE PROCEEDING

```
skill({ name: "modular" })
skill({ name: "production-readiness" })
skill({ name: "testing-strategy" })
skill({ name: "security-universal" })
```

---

## Overview

Transform Jarvis from a barebones developer tool into a **fully customizable** polished application while preserving the signature Metal orb + hex grid aesthetic as the **default**. Add Alacritty/OmegaPowerShell-style configuration where users can customize **everything**, settings UI, Sparkle updates, and proper packaging.

**Core Principle**: Every visual, behavioral, and functional aspect should be configurable. Defaults = current behavior.

---

## Context

Jarvis is a personal AI assistant with:
- Swift/Metal frontend (3D orb, hex grid, WKWebView panels)
- Python backend (voice, skills, LLM routing, livechat, games)
- Presence system (identity, client/server)
- 8+ HTML games (asteroids, tetris, pinball, etc.)
- Livechat with Supabase Realtime + E2E encryption
- Currently requires manual setup (venv, pip, Swift build)
- No customization, no packaging, no update mechanism

Users want to:
- **Customize EVERYTHING**: colors, fonts, opacity, layout, background, orb
- **Startup options**: skip boot, default panels, auto-launch chat/game
- **Voice options**: disable entirely, PTT vs voice-activation
- **Performance**: faster startup, quality settings
- **Remap keyboard shortcuts**
- **Select audio input devices**
- **Persist sessions across restarts**
- **Install via DMG, auto-update**

---

## Scope

### In Scope
- XDG-style config system (`~/.config/jarvis/`)
- YAML configuration file with **comprehensive** validation
- Theme system with 8 built-in themes + custom theme support
- **Full visual customization**: background (image/video/gradient/solid/none), orb (size/color/position/intensity), fonts, colors, opacity
- **Startup customization**: boot animation (skip/speed), default panels, auto-launch actions
- **Voice customization**: enable/disable, PTT vs voice-activation, device selection
- **Performance options**: quality presets, frame rate, animation speed
- In-app settings overlay panel (categorized: Appearance, Startup, Voice, Keybinds, Panels, Games, About)
- Remappable keyboard shortcuts
- Audio device selection
- Session history persistence
- Panel focus fixes (tab in/out)
- main.py modularization (1735 → <80 lines per file)
- App bundling + DMG packaging
- Sparkle auto-update framework

### Out of Scope
- Cross-platform support (macOS only)
- Electron/web-based UI
- Cloud sync for settings

### Customization Philosophy
**Everything is customizable.** If a user can see it, hear it, or interact with it, they should be able to modify it:

| Category | Customizable Elements |
|----------|----------------------|
| **Visual** | Background (image/video/gradient/solid/none), Visualizer (orb/image/video/particles/waveform/none), colors, fonts, opacity, borders, shadows, animations |
| **Audio** | Voice enable/disable, input device, PTT vs VAD, sounds, volumes |
| **Behavior** | Startup sequence, default panels, auto-launch actions, keyboard shortcuts |
| **Panels** | Count, size, layout, history persistence, input behavior |
| **Games** | Enable/disable per game, custom games, fullscreen behavior |
| **Performance** | Frame rate, quality presets, mesh detail, bloom passes |

**Defaults = Current Behavior.** Users who don't touch config get the existing Jarvis experience.

---

## Architecture Overview

```
~/.config/jarvis/
├── config.yaml           # Main configuration
├── themes/
│   └── custom.yaml       # User themes
├── sessions/
│   └── history.db        # SQLite session storage
└── updates/
    └── appcast.xml       # Sparkle cache

jarvis/
├── metal-app/
│   └── Sources/JarvisBootup/
│       ├── Config/                # NEW
│       │   ├── ConfigManager.swift
│       │   ├── ThemeManager.swift
│       │   └── KeybindManager.swift
│       ├── UI/                    # NEW
│       │   ├── SettingsOverlay.swift
│       │   ├── AudioDevicePicker.swift
│       │   └── ShortcutRecorder.swift
│       ├── Session/               # NEW
│       │   └── SessionStore.swift
│       └── ...existing files
├── jarvis/
│   ├── config/                    # NEW - Python config loader
│   │   ├── __init__.py
│   │   ├── loader.py
│   │   └── schema.py
│   ├── commands/                  # NEW - extracted from main.py
│   │   ├── __init__.py
│   │   ├── detection.py
│   │   ├── games.py
│   │   └── execution.py
│   ├── session/                   # NEW - session management
│   │   ├── __init__.py
│   │   ├── history.py
│   │   └── persistence.py
│   └── ...existing modules
├── setup.sh                       # NEW - one-click setup
├── package.sh                     # NEW - build DMG
└── resources/
    ├── themes/                    # NEW - built-in themes
    │   ├── jarvis-dark.yaml
    │   ├── nord.yaml
    │   └── ...
    └── appcast.xml.in             # NEW - Sparkle template
```

---

## Comprehensive Config Schema

**Location**: `~/.config/jarvis/config.yaml`

**Every option documented with its default value. Defaults = current behavior.**

```yaml
# =============================================================================
# JARVIS CONFIGURATION
# =============================================================================
# All options have sensible defaults matching the current behavior.
# Only override what you want to change.
# =============================================================================

# -----------------------------------------------------------------------------
# THEME
# -----------------------------------------------------------------------------

theme:
  # Built-in: jarvis-dark, jarvis-light, nord, dracula, catppuccin-mocha,
  #           tokyo-night, gruvbox-dark, solarized-dark
  # Or path to custom theme: "/path/to/my-theme.yaml"
  name: "jarvis-dark"

# -----------------------------------------------------------------------------
# APPEARANCE - Colors (override theme)
# -----------------------------------------------------------------------------

colors:
  primary: "#00d4ff"              # Main accent color (cyan)
  secondary: "#ff6b00"            # Secondary accent (orange)
  background: "#000000"           # Main background
  panel_bg: "rgba(0,0,0,0.93)"    # Panel background with alpha
  text: "#f0ece4"                 # Primary text
  text_muted: "#888888"           # Dimmed text
  border: "rgba(0,212,255,0.12)"  # Default border
  border_focused: "rgba(0,212,255,0.5)"  # Focused panel border
  
  # Message colors
  user_text: "rgba(140,190,220,0.65)"
  tool_read: "rgba(100,180,255,0.9)"
  tool_edit: "rgba(255,180,80,0.9)"
  tool_write: "rgba(255,180,80,0.9)"
  tool_run: "rgba(80,220,120,0.9)"
  tool_search: "rgba(200,150,255,0.9)"
  
  # Status colors
  success: "#00ff88"
  warning: "#ff6b00"
  error: "#ff4444"

# -----------------------------------------------------------------------------
# APPEARANCE - Typography
# -----------------------------------------------------------------------------

font:
  family: "Menlo"                 # Font family
  size: 13                        # Base font size (px)
  title_size: 15                  # Title bar font size
  line_height: 1.6                # Line height multiplier

# -----------------------------------------------------------------------------
# APPEARANCE - Layout
# -----------------------------------------------------------------------------

layout:
  panel_gap: 2                    # Gap between panels (px)
  border_radius: 4                # Panel corner radius (px)
  padding: 14                     # Panel padding (px)
  max_panels: 5                   # Maximum concurrent panels
  default_panel_width: 0.72       # Default panel width (% of screen)
  scrollbar_width: 3              # Scrollbar width (px)

# -----------------------------------------------------------------------------
# APPEARANCE - Opacity / Transparency
# -----------------------------------------------------------------------------

opacity:
  background: 1.0                 # Overall background (0 = fully transparent)
  panel: 0.93                     # Panel background
  orb: 1.0                        # Orb visibility
  hex_grid: 0.8                   # Hex grid background
  hud: 1.0                        # HUD text overlay

# -----------------------------------------------------------------------------
# BACKGROUND - Visual background options
# -----------------------------------------------------------------------------

background:
  # Mode: "hex_grid" (default), "solid", "image", "video", "gradient", "none"
  mode: "hex_grid"
  
  # For mode: "solid"
  solid_color: "#000000"
  
  # For mode: "image"
  image_path: ""                  # "/path/to/image.jpg"
  image_fit: "cover"              # "cover", "contain", "fill", "tile"
  image_blur: 0                   # Blur amount (px)
  image_opacity: 1.0              # Image opacity (0-1)
  
  # For mode: "video"
  video_path: ""                  # "/path/to/video.mp4"
  video_loop: true
  video_muted: true
  video_fit: "cover"
  
  # For mode: "gradient"
  gradient_type: "radial"         # "linear", "radial"
  gradient_colors:                # 2+ colors
    - "#000000"
    - "#0a1520"
  gradient_angle: 180             # For linear gradients (degrees)
  
  # Hex grid options (when mode: "hex_grid")
  hex_grid:
    color: "#00d4ff"
    opacity: 0.08
    animation_speed: 1.0          # Multiplier (0 = static)
    glow_intensity: 0.5

# -----------------------------------------------------------------------------
# VISUALIZER - The main visual element (orb by default)
# -----------------------------------------------------------------------------

visualizer:
  # Core
  enabled: true                   # Show/hide visualizer entirely
  type: "orb"                     # "orb", "image", "video", "particle", "waveform", "none"
  
  # Position & Size
  position_x: 0.0                 # Horizontal offset (-1 to 1)
  position_y: 0.0                 # Vertical offset (-1 to 1)
  scale: 1.0                      # Size multiplier (0.1 - 3.0)
  anchor: "center"                # "center", "top-left", "top-right", "bottom-left", "bottom-right"
  
  # Reactivity
  react_to_audio: true            # React to microphone/audio levels
  react_to_state: true            # Change based on listening/speaking/skill state
  
  # --------------------------------------------------------------------------
  # Type: "orb" (default 3D sphere)
  # --------------------------------------------------------------------------
  orb:
    color: "#00d4ff"              # Primary color
    secondary_color: "#0088aa"    # Gradient/shadow color
    intensity_base: 1.0           # Base brightness
    bloom_intensity: 1.0          # Glow effect strength
    rotation_speed: 1.0           # Rotation speed multiplier
    mesh_detail: "high"           # "low" (24x32), "medium" (48x64), "high" (96x128)
    wireframe: false              # Show wireframe only
    inner_core: true              # Show inner glowing core
    outer_shell: true             # Show outer transparent shell
    
  # --------------------------------------------------------------------------
  # Type: "image" (static or animated image)
  # --------------------------------------------------------------------------
  image:
    path: ""                      # "/path/to/image.png" or GIF
    fit: "contain"                # "contain", "cover", "fill"
    opacity: 1.0
    animation: "none"             # "none", "pulse", "rotate", "bounce", "float"
    animation_speed: 1.0
    
  # --------------------------------------------------------------------------
  # Type: "video" (looping video)
  # --------------------------------------------------------------------------
  video:
    path: ""                      # "/path/to/video.mp4"
    loop: true
    muted: true
    fit: "cover"
    opacity: 1.0
    sync_to_audio: false          # Sync playback to audio levels
    
  # --------------------------------------------------------------------------
  # Type: "particle" (particle system)
  # --------------------------------------------------------------------------
  particle:
    style: "swirl"                # "swirl", "fountain", "fire", "snow", "stars", "custom"
    count: 500                    # Number of particles
    color: "#00d4ff"
    size: 2.0                     # Particle size
    speed: 1.0                    # Movement speed
    lifetime: 3.0                 # Particle lifetime (seconds)
    custom_shader: ""             # Path to custom Metal shader (advanced)
    
  # --------------------------------------------------------------------------
  # Type: "waveform" (audio waveform visualization)
  # --------------------------------------------------------------------------
  waveform:
    style: "bars"                 # "bars", "line", "circular", "mirror"
    color: "#00d4ff"
    bar_count: 64                 # Number of bars (for "bars" style)
    bar_width: 3.0
    bar_gap: 2.0
    height: 100                   # Max height (px)
    smoothing: 0.8                # Smoothing factor (0-1)
    
  # --------------------------------------------------------------------------
  # Per-state overrides (multiply base values)
  # --------------------------------------------------------------------------
  state_listening:
    scale: 1.0
    intensity: 1.0
    color: null                   # null = use default
  state_speaking:
    scale: 1.1
    intensity: 1.4
    color: null
  state_skill:
    scale: 0.9
    intensity: 1.2
    color: "#ffaa00"              # Orange for skill mode
  state_chat:
    scale: 0.55
    position_x: 0.10
    position_y: 0.30
    intensity: 1.3
  state_idle:
    scale: 0.8
    intensity: 0.6
    color: "#444444"              # Dimmed when idle

# -----------------------------------------------------------------------------
# STARTUP - Boot sequence and initial state
# -----------------------------------------------------------------------------

startup:
  # Boot animation
  boot_animation:
    enabled: true                 # Play boot animation on launch
    duration: 27.0                # Animation duration (seconds)
    skip_on_key: true             # Press any key to skip
    music_enabled: true           # Play boot music
    voiceover_enabled: true       # Play boot voiceover
  
  # Fast start (skip straight to a state)
  fast_start:
    enabled: false                # If true, skip boot animation
    delay: 0.5                    # Brief fade-in (seconds)
  
  # What to show after boot/skip
  on_ready:
    action: "listening"           # "listening", "chat", "game", "skill", "panels"
    
    # For action: "panels"
    panels:
      count: 1                    # Number of panels (1-5)
      titles:                     # Panel titles
        - "Bench 1"
      # Or auto-create empty panels:
      auto_create: true
    
    # For action: "chat"
    chat:
      room: "general"             # Chat room name
    
    # For action: "game"
    game:
      name: "wordle"              # Game to launch
    
    # For action: "skill"
    skill:
      name: "code_assistant"      # Skill to activate

# -----------------------------------------------------------------------------
# VOICE - Speech recognition and audio
# -----------------------------------------------------------------------------

voice:
  enabled: true                   # Enable/disable voice entirely
  
  # Input mode
  mode: "ptt"                     # "ptt" (push-to-talk) or "vad" (voice-activity)
  
  # PTT settings (when mode: "ptt")
  ptt:
    key: "Option+Period"          # Push-to-talk keybind
    cooldown: 0.3                 # Time to keep listening after key release (seconds)
  
  # VAD settings (when mode: "vad")
  vad:
    silence_threshold: 1.0        # Seconds of silence to stop recording
    energy_threshold: 300         # Voice energy threshold
  
  # Audio device
  input_device: "default"         # Device name or "default"
  sample_rate: 24000
  whisper_sample_rate: 16000
  
  # Feedback sounds
  sounds:
    enabled: true
    volume: 0.5                   # 0.0 - 1.0
    listen_start: true            # Play sound when listening starts
    listen_end: true              # Play sound when listening ends

# -----------------------------------------------------------------------------
# KEYBINDS - Keyboard shortcuts
# -----------------------------------------------------------------------------

keybinds:
  push_to_talk: "Option+Period"
  open_assistant: "Cmd+G"
  new_panel: "Cmd+T"
  close_panel: "Escape+Escape"    # Double escape
  toggle_fullscreen: "Cmd+F"
  open_settings: "Cmd+,"
  focus_panel_1: "Cmd+1"
  focus_panel_2: "Cmd+2"
  focus_panel_3: "Cmd+3"
  focus_panel_4: "Cmd+4"
  focus_panel_5: "Cmd+5"
  cycle_panels: "Tab"             # Cycle through open panels
  cycle_panels_reverse: "Shift+Tab"

# -----------------------------------------------------------------------------
# PANELS - Chat panel behavior
# -----------------------------------------------------------------------------

panels:
  # History/persistence
  history:
    enabled: true                 # Save chat history
    max_messages: 1000            # Per panel
    restore_on_launch: true       # Reopen panels from last session
  
  # Input behavior
  input:
    multiline: true               # Allow multiline input (Shift+Enter)
    auto_grow: true               # Expand textarea with content
    max_height: 300               # Max textarea height (px)
  
  # Focus behavior
  focus:
    restore_on_activate: true     # Refocus when app regains focus
    show_indicator: true          # Visual focus indicator
    border_glow: true             # Glow effect on focused panel

# -----------------------------------------------------------------------------
# GAMES - HTML game settings
# -----------------------------------------------------------------------------

games:
  # Available games (can disable specific ones)
  enabled:
    wordle: true
    connections: true
    asteroids: true
    tetris: true
    pinball: true
    doodlejump: true
    minesweeper: true
    draw: true
    subway: true
    videoplayer: true
  
  # Fullscreen behavior
  fullscreen:
    keyboard_passthrough: true    # Forward all keys to game
    escape_to_exit: true          # Escape exits fullscreen
  
  # Custom game paths (for user-added games)
  custom_paths: []
  # custom_paths:
  #   - name: "my-game"
  #     path: "/path/to/game.html"

# -----------------------------------------------------------------------------
# LIVECHAT - Real-time chat settings
# -----------------------------------------------------------------------------

livechat:
  enabled: true
  
  # Connection
  server_port: 19847              # Local HTTP server port
  connection_timeout: 10          # Seconds before showing error
  
  # User identity
  nickname:
    default: ""                   # Empty = prompt on first join
    persist: true                 # Save nickname to localStorage
    allow_change: true            # Allow clicking header to change
    validation:
      min_length: 1
      max_length: 20
      pattern: "^[a-zA-Z0-9_\\- ]+$"  # Allowed characters
  
  # Moderation
  automod:
    enabled: true
    filter_profanity: true
    rate_limit: 5                 # Messages per second
    max_message_length: 500
    spam_detection: true

# -----------------------------------------------------------------------------
# PRESENCE - Identity and presence system
# -----------------------------------------------------------------------------

presence:
  enabled: true
  server_url: ""                  # Empty = use default
  heartbeat_interval: 30          # Seconds

# -----------------------------------------------------------------------------
# PERFORMANCE - Quality and speed settings
# -----------------------------------------------------------------------------

performance:
  # Quality preset: "low", "medium", "high", "ultra"
  preset: "high"
  
  # Individual overrides
  frame_rate: 60                  # Target FPS (30, 60, 120)
  orb_quality: "high"             # "low", "medium", "high" (sphere mesh detail)
  bloom_passes: 2                 # Bloom blur passes (1-4)
  
  # Startup performance
  preload:
    themes: true                  # Preload all themes
    games: false                  # Preload game HTML
    fonts: true                   # Preload custom fonts

# -----------------------------------------------------------------------------
# UPDATES - Sparkle auto-update
# -----------------------------------------------------------------------------

updates:
  check_automatically: true
  channel: "stable"               # "stable" or "beta"
  check_interval: 86400           # Seconds (24 hours)
  auto_download: false            # Download without prompting
  auto_install: false             # Install on quit

# -----------------------------------------------------------------------------
# LOGGING - Debug and diagnostics
# -----------------------------------------------------------------------------

logging:
  level: "INFO"                   # DEBUG, INFO, WARNING, ERROR
  file_logging: true
  max_file_size_mb: 5
  backup_count: 3
  redact_secrets: true            # Hide API keys in logs

# -----------------------------------------------------------------------------
# ADVANCED - Experimental features
# -----------------------------------------------------------------------------

advanced:
  # Experimental features (may change/be removed)
  experimental:
    web_rendering: false          # Use WebKit for orb (instead of Metal)
    metal_debug: false            # Enable Metal validation layers
  
  # Developer options
  developer:
    show_fps: false               # FPS counter overlay
    show_debug_hud: false         # Debug info overlay
    inspector_enabled: false      # Enable WebKit inspector
```

---

## Implementation Phases

Each phase MUST include a test. No phase is done until its test passes.

---

### Phase 1: Project Structure & Setup Script

**Goal**: One-command setup experience

**Steps**:
1. Create `setup.sh` with:
   - Python venv creation (`.venv/`)
   - Pip install from requirements.txt (pinned versions)
   - Swift build (`swift build -c release`)
   - Config directory creation (`~/.config/jarvis/`)
   - Default config copy
   - Pre-flight checks (macOS version, Xcode tools, Python 3.10+)
2. Create `jarvis/config/` module structure
3. Create `jarvis/commands/` module structure
4. Create `jarvis/session/` module structure
5. Update `.gitignore` for new directories
6. Pin versions in `requirements.txt`

**Test**: 
```bash
# Fresh clone in /tmp
cd /tmp && git clone <repo> jarvis-test && cd jarvis-test
./setup.sh
# Assert: .venv exists, metal-app/.build/release/JarvisBootup exists
# Assert: ~/.config/jarvis/config.yaml exists
# Assert: ./start.sh --jarvis launches without error
```

**Pass criteria**: `./setup.sh && ./start.sh --jarvis` works from fresh clone

---

### Phase 2: Configuration System

**Goal**: YAML config with validation and defaults

**Steps**:
1. Create `jarvis/config/schema.py` with Pydantic models for all config options
2. Create `jarvis/config/loader.py`:
   - Load `~/.config/jarvis/config.yaml`
   - Merge with defaults
   - Validate schema
   - Export to JSON for Swift via stdin
3. Create default `config.yaml` with inline comments
4. Update `main.py` to use config loader
5. Pass config to Swift via new stdin message type `{"type": "config", "payload": {...}}`

**Config Schema**:
```python
class FontConfig(BaseModel):
    family: str = "Menlo"
    size: int = 13
    line_height: float = 1.6

class ColorConfig(BaseModel):
    primary: str = "#00d4ff"
    background: str = "#000000"
    panel_bg: str = "rgba(0,0,0,0.93)"
    # ... all colors

class KeybindConfig(BaseModel):
    push_to_talk: str = "Option+Period"
    open_assistant: str = "Cmd+G"
    # ... all keybinds

class JarviConfig(BaseModel):
    font: FontConfig = FontConfig()
    colors: ColorConfig = ColorConfig()
    keybinds: KeybindConfig = KeybindConfig()
    # ... all sections
```

**Test**:
```python
# tests/test_config.py
def test_load_default_config():
    config = load_config()  # No file = defaults
    assert config.font.family == "Menlo"
    assert config.colors.primary == "#00d4ff"

def test_load_custom_config(tmp_path):
    config_file = tmp_path / "config.yaml"
    config_file.write_text("font:\n  family: SF Mono\n  size: 14")
    config = load_config(config_file)
    assert config.font.family == "SF Mono"
    assert config.font.size == 14

def test_invalid_config_rejected():
    # Invalid color should raise validation error
    with pytest.raises(ValidationError):
        validate_color("not-a-color")
```

**Pass criteria**: `pytest tests/test_config.py -v` all pass

---

### Phase 3: Theme System

**Goal**: Built-in themes + custom theme support via CSS variables

**Steps**:
1. Create `resources/themes/` with 8 built-in themes as YAML files
2. Create `ThemeManager.swift`:
   - Load theme from config
   - Convert colors to CSS variables
   - Inject into WKWebView HTML
3. Update `ChatWebViewHTML.swift` to use CSS variables:
   ```css
   :root {
     --color-primary: #00d4ff;
     --color-background: #000000;
     --font-family: Menlo, monospace;
     /* ... */
   }
   body {
     background: var(--color-panel-bg);
     color: var(--color-primary);
     font-family: var(--font-family);
   }
   ```
4. Create theme validation in Python
5. Add theme reload on config change (requires restart prompt)

**Built-in Themes**:
- `jarvis-dark` (default)
- `jarvis-light`
- `nord`
- `dracula`
- `catppuccin-mocha`
- `tokyo-night`
- `gruvbox-dark`
- `solarized-dark`

**Test**:
```swift
// Tests/ThemeManagerTests.swift
func testLoadBuiltInTheme() {
    let theme = ThemeManager.load(name: "nord")
    XCTAssertEqual(theme.colors.primary, "#88c0d0")
}

func testThemeCSSVariables() {
    let theme = ThemeManager.load(name: "jarvis-dark")
    let css = theme.toCSSVariables()
    XCTAssertTrue(css.contains("--color-primary: #00d4ff"))
}
```

**Pass criteria**: Theme loads, CSS variables inject, colors render correctly in panel

---

### Phase 4: Visualizer System (Orb → Multi-Type)

**Goal**: Replace hardcoded orb with configurable visualizer supporting multiple types

**Steps**:
1. Refactor `Renderer.swift` to use `VisualizerManager`:
   - Abstract rendering into protocol `Visualizer`
   - Implement `OrbVisualizer` (current sphere)
   - Implement `ImageVisualizer` (static/animated image)
   - Implement `VideoVisualizer` (looping video)
   - Implement `ParticleVisualizer` (particle system)
   - Implement `WaveformVisualizer` (audio bars)
   - Implement `NullVisualizer` (disabled)
2. Create `VisualizerConfig.swift`:
   - Parse visualizer config from JSON
   - Validate paths, colors, values
   - Provide default configs per type
3. Update `Timeline.swift`:
   - Drive visualizer through abstraction
   - Pass audio levels to visualizer
   - Handle state changes (listening/speaking/skill)
4. Update `Uniforms` struct:
   - Add visualizer-type-specific fields
   - Maintain backward compatibility for orb
5. Add Metal shaders for:
   - Particle system (compute shader)
   - Waveform (vertex displacement)
6. Create `resources/visualizers/`:
   - Sample images, videos for testing
   - Default particle/waveform configs

**Visualizer Types**:
| Type | Description | Metal Required |
|------|-------------|----------------|
| `orb` | 3D sphere (default) | Yes |
| `image` | Static/animated image | No (texture) |
| `video` | Looping video | No (AVPlayer) |
| `particle` | Particle system | Yes (compute) |
| `waveform` | Audio visualization | Yes |
| `none` | Disabled | No |

**Test**:
```swift
func testOrbVisualizer() {
    let config = VisualizerConfig(type: "orb", orb: OrbConfig())
    let viz = VisualizerManager.create(config)
    XCTAssertTrue(viz is OrbVisualizer)
}

func testImageVisualizer() {
    let config = VisualizerConfig(type: "image", image: ImageConfig(path: "test.png"))
    let viz = VisualizerManager.create(config)
    XCTAssertTrue(viz is ImageVisualizer)
}

func testVisualizerDisabled() {
    let config = VisualizerConfig(type: "none")
    let viz = VisualizerManager.create(config)
    XCTAssertTrue(viz is NullVisualizer)
    XCTAssertFalse(viz.isVisible)
}
```

**Pass criteria**: All visualizer types render correctly, config switches type on restart

---

### Phase 5: Background System (Hex Grid → Multi-Type)

**Goal**: Configurable background beyond hex grid

**Steps**:
1. Create `BackgroundManager.swift`:
   - Abstract background rendering into protocol
   - Implement `HexGridBackground` (current)
   - Implement `SolidBackground` (solid color)
   - Implement `ImageBackground` (static image with fit/blur/opacity)
   - Implement `VideoBackground` (looping video)
   - Implement `GradientBackground` (linear/radial)
   - Implement `NullBackground` (transparent)
2. Update `Renderer.swift` composite pass:
   - Draw background layer first
   - Blend visualizer on top
   - Blend HUD on top of that
3. Update fragment shader:
   - Sample background texture if present
   - Apply blur (image mode)
   - Apply opacity
4. For video/animated backgrounds:
   - Use `AVPlayer` + `AVPlayerItemVideoOutput`
   - Convert to Metal texture each frame
   - Handle looping
5. Add background preview in settings UI

**Background Types**:
| Type | Description | Performance |
|------|-------------|-------------|
| `hex_grid` | Animated hex grid (default) | Medium |
| `solid` | Solid color | High |
| `image` | Static image | High |
| `video` | Looping video | Medium-Low |
| `gradient` | CSS-style gradient | High |
| `none` | Transparent | Highest |

**Test**:
```swift
func testHexGridBackground() {
    let bg = BackgroundManager.create(type: "hex_grid")
    XCTAssertTrue(bg is HexGridBackground)
}

func testImageBackgroundWithBlur() {
    let config = BackgroundConfig(
        mode: "image",
        image: ImageConfig(path: "bg.jpg", blur: 10, opacity: 0.8)
    )
    let bg = BackgroundManager.create(config)
    XCTAssertEqual(bg.blurAmount, 10)
    XCTAssertEqual(bg.opacity, 0.8)
}

func testGradientBackground() {
    let config = BackgroundConfig(
        mode: "gradient",
        gradient: GradientConfig(colors: ["#000", "#111"], type: "radial")
    )
    let bg = BackgroundManager.create(config) as! GradientBackground
    XCTAssertEqual(bg.colors.count, 2)
}
```

**Pass criteria**: All background types render, video loops, image blur works

---

### Phase 6: Startup Options

**Goal**: Configurable boot sequence and initial state

**Steps**:
1. Create `StartupManager.swift`:
   - Parse startup config
   - Control boot animation playback
   - Handle fast-start mode
   - Dispatch to initial state
2. Update `Timeline.swift`:
   - Respect `startup.boot_animation.enabled`
   - Support `startup.boot_animation.duration` override
   - Skip to end if `startup.fast_start.enabled`
3. Add `on_ready` action dispatcher:
   - `listening`: Default orb state
   - `panels`: Open N panels with titles
   - `chat`: Launch livechat fullscreen
   - `game`: Launch specific game
   - `skill`: Activate specific skill
4. Update `main.py`:
   - Read startup config
   - Pre-create panels if `on_ready.action = "panels"`
   - Auto-launch game/chat if configured
5. Add startup preview in settings UI

**Startup Actions**:
| Action | Behavior |
|--------|----------|
| `listening` | Default, show orb in listening mode |
| `panels` | Open N panels immediately (skip orb focus) |
| `chat` | Launch livechat fullscreen on ready |
| `game` | Launch specified game fullscreen |
| `skill` | Activate specified skill panel |

**Test**:
```swift
func testBootAnimationSkipped() {
    let config = StartupConfig(fast_start: FastStartConfig(enabled: true))
    let manager = StartupManager(config: config)
    manager.begin()
    XCTAssertFalse(manager.isPlayingBootAnimation)
}

func testOnReadyOpensPanels() {
    let config = StartupConfig(
        on_ready: OnReadyConfig(action: "panels", panels: PanelActionConfig(count: 3))
    )
    let manager = StartupManager(config: config)
    manager.dispatchOnReady()
    XCTAssertEqual(panelCount, 3)
}

func testOnReadyLaunchesGame() {
    let config = StartupConfig(
        on_ready: OnReadyConfig(action: "game", game: GameActionConfig(name: "wordle"))
    )
    let manager = StartupManager(config: config)
    manager.dispatchOnReady()
    XCTAssertTrue(isGameFullscreen)
    XCTAssertEqual(currentGame, "wordle")
}
```

**Pass criteria**: Boot skip works, panels/games/chat launch on ready

---

### Phase 7: Settings UI Overlay

**Goal**: In-app settings panel accessible via gear icon

**Steps**:
1. Create `SettingsOverlay.swift`:
   - Transparent overlay view over Metal content
   - Settings button (gear icon) top-right corner
   - Panel slides in from right with settings categories
   - Categories: Appearance, Visualizer, Background, Startup, Voice, Keybinds, Panels, Games, About
2. Create settings form UI in HTML (loaded in dedicated WKWebView):
   - Font picker (family, size)
   - Color pickers for all customizable colors
   - Theme dropdown
   - Visualizer type selector + type-specific options
   - Background mode selector + mode-specific options
   - Startup options (boot animation, on_ready action)
   - Voice enable/disable toggle, device picker
   - Keybind recorder
   - Audio device dropdown
   - Toggle switches
3. Wire settings changes to config file write
4. Show "Restart required" toast on save
5. Add keyboard shortcut to open settings (Cmd+,)

**Settings Categories**:
| Category | Options |
|----------|---------|
| Appearance | Theme, colors, fonts, opacity, layout |
| Visualizer | Type, position, scale, reactivity, type-specific |
| Background | Mode, image/video path, blur, opacity |
| Startup | Boot animation, fast start, on_ready action |
| Voice | Enable/disable, PTT vs VAD, device, sounds |
| Keybinds | All keyboard shortcuts |
| Panels | History, persistence, focus behavior |
| Games | Enable/disable, custom paths |
| About | Version, updates, logs |

**Test**:
```swift
func testSettingsButtonOpensOverlay() {
    let app = launchApp()
    app.buttons["Settings"].click()
    XCTAssertTrue(app.otherElements["SettingsOverlay"].exists)
}

func testSettingsPersisted() {
    let app = launchApp()
    openSettings()
    selectTheme("nord")
    saveSettings()
    restartApp()
    XCTAssertEqual(currentTheme(), "nord")
}

func testVisualizerTypeChange() {
    openSettings()
    selectVisualizerType("particle")
    saveSettings()
    restartApp()
    XCTAssertTrue(currentVisualizer is ParticleVisualizer)
}
```

**Pass criteria**: Settings UI opens, all categories work, changes save to config.yaml, restart applies

---

### Phase 8: Keyboard Shortcuts System
**Pass criteria**: Settings UI opens, all categories work, changes save to config.yaml, restart applies

---

### Phase 8: Keyboard Shortcuts System

**Goal**: Remappable shortcuts with visual recorder

**Steps**:
1. Create `KeybindManager.swift`:
   - Parse keybind strings ("Option+Period", "Cmd+G")
   - Convert to NSEvent flags/keyCode
   - Store in config
   - Emit JSON to Python for PTT
2. Update `main.swift` to use KeybindManager instead of hardcoded keycodes
3. Create `ShortcutRecorder.swift`:
   - Capture next keypress
   - Display current shortcut
   - Validate (no conflicts, no reserved keys)
4. Add keybind settings section in settings UI
5. Support modifier combos (Cmd+Shift+G, etc.)

**Default Keybinds**:
| Action | Default |
|--------|---------|
| Push to Talk | Option+Period |
| Open Assistant | Cmd+G |
| New Panel | Cmd+T |
| Close Panel | Escape+Escape |
| Toggle Fullscreen | Cmd+F |
| Open Settings | Cmd+, |
| Focus Panel 1-5 | Cmd+1 through Cmd+5 |

**Test**:
```swift
func testCustomKeybindFires() {
    KeybindManager.set("open_assistant", to: "Cmd+Shift+A")
    pressKey("A", modifiers: [.command, .shift])
    XCTAssertTrue(didFireOpenAssistant)
}

func testKeybindConflict() {
    KeybindManager.set("open_assistant", to: "Cmd+T")
    XCTAssertFalse(KeybindManager.isValid("open_assistant", "Cmd+T")) // conflicts with new_panel
}
```

**Pass criteria**: Custom shortcuts work, conflicts detected, persisted in config

---

### Phase 6: Audio Device Selection

**Goal**: Select input device for voice

**Steps**:
1. Create `AudioDevicePicker.swift`:
   - Enumerate all input devices via CoreAudio
   - Display in dropdown with device names
   - Show default device indicator
   - Support device ID storage in config
2. Update `StdinReader.swift` to receive device selection from Python
3. Update Python voice module to use selected device:
   - Use `sounddevice` with device index
   - Fallback to default if device not found
4. Add audio level meter in settings (visual feedback)
5. Store device preference by ID + name (survives USB re-plug)

**Test**:
```swift
func testDeviceEnumeration() {
    let devices = AudioDevicePicker.inputDevices()
    XCTAssertTrue(devices.count > 0)
}

func testDeviceSelection() {
    let device = AudioDevicePicker.inputDevices().first!
    selectDevice(device.id)
    XCTAssertEqual(Config.audio.input_device, device.id)
}
```

**Pass criteria**: Device picker shows all mics, selection persists, voice uses correct device

---

### Phase 9: Voice Mode & Audio System

**Goal**: Full voice customization including disable option, PTT vs VAD

**Steps**:
1. Create `VoiceManager.swift`:
   - Parse voice config
   - Handle PTT vs VAD mode switching
   - Coordinate with Python audio module
2. Add voice enable/disable:
   - `voice.enabled: false` → Skip all voice initialization
   - Show visual indicator when voice disabled
   - Allow keyboard-only operation
3. Implement VAD mode:
   - Energy threshold detection in Python
   - Silence timeout to stop recording
   - Visual feedback when recording auto-stops
4. Update Python audio module:
   - Support both PTT and VAD modes
   - Device selection with fallback
   - Configurable sample rates
5. Add voice settings in UI:
   - Enable/disable toggle
   - Mode selector (PTT/VAD)
   - VAD threshold slider
   - Device picker
   - Feedback sounds toggles

**Voice Modes**:
| Mode | Trigger | Use Case |
|------|---------|----------|
| `ptt` | Hold key | Precise control, noisy environments |
| `vad` | Auto-detect | Hands-free, quiet environments |
| `disabled` | None | Keyboard-only, no mic |

**Test**:
```swift
func testVoiceDisabled() {
    let config = VoiceConfig(enabled: false)
    let manager = VoiceManager(config: config)
    XCTAssertFalse(manager.isInitialized)
    XCTAssertFalse(manager.canRecord)
}

func testVADMode() {
    let config = VoiceConfig(mode: "vad", vad: VADConfig(silence_threshold: 1.0))
    let manager = VoiceManager(config: config)
    XCTAssertEqual(manager.mode, .vad)
}
```

**Pass criteria**: Voice can be disabled, PTT and VAD both work, settings persist

---

### Phase 10: Session Persistence

**Goal**: Chat history survives app restart

**Steps**:
1. Create SQLite schema for sessions:
   ```sql
   CREATE TABLE sessions (
     id INTEGER PRIMARY KEY,
     created_at TEXT,
     title TEXT
   );
   CREATE TABLE messages (
     id INTEGER PRIMARY KEY,
     session_id INTEGER,
     panel INTEGER,
     speaker TEXT,
     content TEXT,
     created_at TEXT,
     FOREIGN KEY (session_id) REFERENCES sessions(id)
   );
   ```
2. Create `jarvis/session/history.py`:
   - Store messages as they arrive
   - Load recent sessions
   - Search history
3. Create `SessionStore.swift`:
   - Receive history from Python
   - Display in panels on restore
4. Add config option: `session.save_history: true/false`
5. Add "Clear History" button in settings
6. Restore panel layout + last N messages on launch

**Test**:
```python
def test_message_persistence():
    store = SessionStore(":memory:")
    store.save_message(session_id=1, panel=0, speaker="user", content="Hello")
    store.save_message(session_id=1, panel=0, speaker="gemini", content="Hi there")
    messages = store.load_session(1)
    assert len(messages) == 2
    assert messages[0]["content"] == "Hello"
```

**Pass criteria**: Messages persist, restore on restart, clear history works

---

### Phase 11: Panel Focus Refactor

**Goal**: Fix tab in/out, reliable focus tracking

**Steps**:
1. Create `FocusManager.swift`:
   - Track active panel explicitly
   - Handle window focus events
   - Handle Cmd+Tab back to app
   - Emit focus state to Python
2. Update `ChatWebView.swift`:
   - Refactor `updateFocusIndicators()` to be deterministic
   - Add focus restoration on app reactivate
   - Fix race condition in `makeFirstResponder`
3. Update `main.swift`:
   - Use FocusManager for all focus decisions
   - Add debug logging for focus events
4. Add visual focus indicator (brighter border)
5. Handle Tab key to cycle panels (configurable)

**Focus States**:
```
App Active + Panel Focused → Bright border, keyboard input
App Active + Panel Blurred → Dim border, click to focus
App Inactive → All panels dim, restore on activate
Fullscreen Game → Game has focus, Escape exits
```

**Test**:
```swift
func testFocusRestoresOnActivate() {
    let app = launchApp()
    openPanel()
    app.deactivate()
    app.activate()
    XCTAssertTrue(panels[0].isFirstResponder)
}

func testTabCyclesPanels() {
    let app = launchApp()
    openTwoPanels()
    pressKey("Tab")
    XCTAssertEqual(activePanel, 1)
    pressKey("Tab")
    XCTAssertEqual(activePanel, 0)
}
```

**Pass criteria**: Tab cycles panels, Cmd+Tab restores focus, click focuses correctly

---

### Phase 12: main.py Modularization

**Goal**: Reduce main.py from 1735 lines to <100 lines

**Steps**:
1. Extract to `jarvis/commands/detection.py`:
   - `detect_game_command()` function
   - All game detection patterns
   - Command parsing logic
2. Extract to `jarvis/commands/execution.py`:
   - `execute_command()` function
   - Game launch logic
   - Subprocess handling
3. Extract to `jarvis/input/`:
   - `handle_stdin_message()` 
   - Input validation
   - Message routing
4. Extract to `jarvis/session/`:
   - Panel state management
   - Session lifecycle
5. Refactor `main.py` to:
   - Import modules
   - Initialize components
   - Run main loop (~80 lines)

**Module Structure**:
```
jarvis/
├── main.py              # ~80 lines: init + main loop
├── config/
│   ├── __init__.py
│   ├── loader.py        # Config loading
│   └── schema.py        # Pydantic models
├── commands/
│   ├── __init__.py
│   ├── detection.py     # Command pattern matching
│   ├── games.py         # Game-specific handlers
│   └── execution.py     # Subprocess execution
├── input/
│   ├── __init__.py
│   ├── stdin.py         # Stdin message handling
│   └── validation.py    # Input sanitization
├── session/
│   ├── __init__.py
│   ├── history.py       # SQLite persistence
│   └── state.py         # Panel state
└── voice/
    ├── __init__.py
    └── audio.py         # Audio device config
```

**Test**:
```python
def test_game_detection():
    from jarvis.commands.detection import detect_game_command
    result = detect_game_command("play wordle")
    assert result["game"] == "wordle"
    assert result["action"] == "play"

def test_command_execution():
    from jarvis.commands.execution import execute_command
    # Mock subprocess
    result = execute_command({"type": "shell", "command": "echo test"})
    assert result["output"] == "test"
```

**Pass criteria**: main.py < 100 lines, all imports work, existing tests pass

---

### Phase 13: App Packaging

**Goal**: Distributable app bundle + DMG

**Steps**:
1. Create `Jarvis.xcodeproj` or use SwiftPM resources:
   - Bundle Python runtime (or require system Python)
   - Bundle `.venv` or create at first launch
   - Bundle `resources/` themes
   - Proper Info.plist (bundle ID, version, privacy)
2. Add app icon (`.icns`)
3. Create `package.sh`:
   - Build release (`swift build -c release`)
   - Create app bundle structure
   - Sign with ad-hoc signature (dev) or proper cert (release)
   - Create DMG with background image
4. Add to Git:
   - `Jarvis.xcodeproj/`
   - `resources/icon.icns`
   - `package.sh`
   - `dmg-background.png`
5. Support both:
   - Development mode (run from source)
   - Packaged mode (run from app bundle)

**App Bundle Structure**:
```
Jarvis.app/
├── Contents/
│   ├── MacOS/
│   │   └── JarvisBootup         # Swift binary
│   ├── Resources/
│   │   ├── app.icns
│   │   ├── themes/              # Built-in themes
│   │   └── python/              # Bundled or symlink
│   ├── Frameworks/
│   ├── Info.plist
│   └── PkgInfo
```

**Test**:
```bash
./package.sh
# Assert: Jarvis.app exists
# Assert: open Jarvis.app launches
# Assert: Config loads from ~/.config/jarvis/
hdiutil attach Jarvis.dmg
# Assert: DMG mounts, contains Jarvis.app
```

**Pass criteria**: DMG installs, app launches, works like source build

---

### Phase 14: Sparkle Auto-Update

**Goal**: Built-in auto-update via Sparkle

**Steps**:
1. Add Sparkle framework to project:
   - SPM dependency or Carthage
   - Link in Xcode/SwiftPM
2. Create `Updater.swift`:
   - Check for updates on launch (configurable)
   - Show update notification
   - Download + install update
   - Relaunch app
3. Create `resources/appcast.xml.in` template
4. Create GitHub Actions workflow:
   - On release tag, build DMG
   - Generate appcast.xml with version + download URL
   - Upload to GitHub Releases + appcast URL
5. Add "Check for Updates" in settings
6. Sign DMG with developer cert for Sparkle verification

**Appcast Format**:
```xml
<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
  <channel>
    <title>Jarvis Updates</title>
    <item>
      <title>Version 1.2.0</title>
      <pubDate>Wed, 25 Feb 2026 00:00:00 +0000</pubDate>
      <sparkle:version>1.2.0</sparkle:version>
      <sparkle:shortVersionString>1.2.0</sparkle:shortVersionString>
      <sparkle:minimumSystemVersion>12.0</sparkle:minimumSystemVersion>
      <enclosure url="https://github.com/.../Jarvis-1.2.0.dmg"
                 sparkle:edSignature="..."
                 length="12345678"
                 type="application/octet-stream"/>
      <description><![CDATA[
        ## What's New
        - Theme system with 8 built-in themes
        - Remappable keyboard shortcuts
        - Session history persistence
      ]]></description>
    </item>
  </channel>
</rss>
```

**Test**:
```swift
func testUpdateCheck() {
    let updater = Updater()
    updater.checkForUpdates()
    // Mock appcast response
    XCTAssertTrue(updater.updateAvailable)
}

func testUpdateInstall() {
    // Integration test with test appcast
    let updater = Updater()
    updater.installUpdate()
    // Assert: Download completes, app relaunches
}
```

**Pass criteria**: Update check works, DMG downloads, app updates

---

## Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Breaking existing workflows | High | Medium | All changes additive, defaults match current behavior |
| Focus tracking bugs | High | Medium | Comprehensive FocusManager, extensive logging, phase-gate testing |
| Config schema changes | Medium | Low | Versioned schema, migration function |
| Sparkle signing issues | Medium | Medium | Test with ad-hoc first, document cert process |
| Python bundle size | Low | High | Require system Python 3.10+, don't bundle |
| Theme CSS regressions | Medium | Medium | Visual regression tests for each theme |

---

## Rollback Plan

| Component | Rollback |
|-----------|----------|
| Config | Delete `~/.config/jarvis/`, defaults regenerate |
| Theme | Set `theme: jarvis-dark` in config |
| Keybinds | Reset to defaults in settings |
| Session | Clear `sessions/history.db` |
| App bundle | Delete `Jarvis.app`, run from source |

---

## Success Criteria

- [ ] Fresh clone → `./setup.sh` → working app in < 2 minutes
- [ ] Settings UI opens, all options work, restart applies
- [ ] Theme change reflects in all UI elements
- [ ] Custom keybinds work without code changes
- [ ] Audio device selection persists across launches
- [ ] Chat history survives app quit/restart
- [ ] Tab key cycles panels reliably
- [ ] Cmd+Tab back to app restores focus
- [ ] main.py < 100 lines
- [ ] DMG installs on clean Mac, app launches
- [ ] Sparkle detects and installs updates
- [ ] All tests pass (`pytest && swift test`)

---

## Approval

- [ ] User approved this plan

---

## Implementation Notes

_To be updated during implementation_

| Date | Phase | Status | Notes |
|------|-------|--------|-------|
| | | | |
