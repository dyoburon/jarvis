# PLAN: Jarvis Livechat Plugin

Date: 2026-02-25
Status: Approved (Revised — Rust WASM eliminated, JS automod inline)

## REQUIRED SKILLS - LOAD BEFORE PROCEEDING

skill({ name: "modular" })
skill({ name: "testing-strategy" })
skill({ name: "security-universal" })
skill({ name: "websockets" })
skill({ name: "real-time" })
skill({ name: "rate-limiting" })
skill({ name: "supabase" })
skill({ name: "input-validation" })
skill({ name: "frontend-security" })

## Overview

Build a decentralized, encrypted livechat plugin for Jarvis. Any user can enter.
Messages are automoderated via inline JavaScript (keyword filter, rate limiter, spam detection)
running receiver-side in the browser. All messages relay through Supabase Realtime Broadcast
(free tier) so peer IPs are hidden. Messages are E2E encrypted client-side before sending.

## Architecture

```
Jarvis Metal App
  └─ iframe: chat.html (local file, single self-contained HTML)
       ├─ Supabase Realtime Broadcast (message relay, $0)
       ├─ JS AutoMod (receiver-side filtering, inline)
       └─ Web Crypto API (E2E encryption, AES-GCM)
```

## Context

- Jarvis loads games/features as local HTML iframes via `send_chat_iframe_fullscreen()`
- Voice commands detected via `_is_X_command()` pattern in `main.py`
- 8 existing games follow this exact pattern — we replicate it
- Users want: public chat, encrypted, automoderated, $0 cost, customizable

## Design System (must match existing Jarvis apps)

All visual styling must match the existing Jarvis game aesthetic:

```css
/* Core palette */
--bg:          #0a0a0a;     /* near-black background */
--panel-bg:    #0d1117;     /* dark blue-black panels */
--primary:     #00e5ff;     /* cyan — text, borders, accents */
--accent:      #ff6b00;     /* orange — highlights, alerts */
--success:     #00ff88;     /* green — online status, success */
--muted:       #888;        /* gray — secondary text */
--border:      #1a2a3a;     /* subtle borders */
--border-lit:  #2a4a5a;     /* brighter borders on interactive */

/* Typography */
font-family: 'Courier New', monospace;

/* Glow effects (signature Jarvis look) */
text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);   /* cyan glow */
box-shadow:  0 0 30px rgba(0, 229, 255, 0.2);    /* panel glow */

/* Buttons: border-radius 4px, glow on hover/active */
/* Borders: 1-2px solid, rounded 4-8px */
/* Overlays: rgba(0,0,0,0.7) backdrop */
```

## Scope

### In scope
- Inline JS automod (keyword filter, rate limiting, spam detection)
- chat.html frontend (vanilla HTML/JS, single self-contained file)
- Supabase Realtime Broadcast integration
- Client-side E2E encryption (Web Crypto API, AES-GCM)
- Voice command integration in main.py ("open chat", "launch chat", etc.)
- Nicknames, user presence, connection status
- Customizable ban word list
- Visual design matching Jarvis design system (dark theme, cyan/orange, glow effects, monospace)

### Out of scope
- User accounts / authentication
- Message history / persistence (ephemeral by design)
- Voice/video chat
- File sharing
- Admin panel (future enhancement)
- Mobile app support

## Revision Log

- **2026-02-25 (v2)**: Eliminated Rust WASM automod. Keyword filtering, rate limiting, and spam
  detection are trivial string/counter operations — JavaScript handles them in ~80 lines with zero
  performance difference at chat-message-per-second scale. This removes the Rust toolchain
  dependency, build step, and WASM loading complexity entirely. Automod is now inline JS in
  chat.html. Old Phase 1 (Rust) eliminated; old Phase 2 becomes new Phase 1.

## Cost

| Component | Service | Cost |
|-----------|---------|------|
| Message relay | Supabase Realtime Broadcast | $0 (2M msg/month, 200 connections) |
| Automod | Inline JavaScript (local) | $0 |
| Encryption | Web Crypto API (browser) | $0 |
| Frontend | Local HTML file | $0 |
| **Total** | | **$0, no credit card** |

## Implementation Phases

### Phase 1: Chat Frontend — Core Messaging + AutoMod

**Steps:**
1. Create `chat.html` in repo root (matches pinball.html, tetris.html pattern)
2. Implement inline JS AutoMod class:
   - `checkMessage(text)` — keyword matching against ban list (case-insensitive, word boundary)
   - `checkRateLimit(userId, timestamp)` — sliding window rate limiter (N msgs per window)
   - `checkSpam(text, userId)` — repeated character/message detection
   - Default ban word list embedded, with API to add/remove words at runtime
3. Implement Supabase Realtime Broadcast connection:
   - Join a named channel (default: "jarvis-livechat")
   - Send/receive messages via Broadcast
   - Handle peer join/leave via Presence
4. Implement E2E encryption:
   - Derive AES-GCM key from room name + app salt via PBKDF2
   - Encrypt message before sending to Supabase
   - Decrypt received message before display
5. Receiver-side pipeline: receive → decrypt → automod filter → display (or block)
6. HTML-escape all message text before render (XSS prevention) — textContent only, never innerHTML
7. UI: message list, input box, nickname picker, connection status, user count
8. Visual design matching Jarvis design system (see Design System section)

**Files created:**
- `chat.html` (self-contained with inline JS + Supabase CDN)

**Test:** Manual integration test + automated checks
- Clean message passes automod
- Banned keyword blocked (exact, case-insensitive, word boundary)
- Rate limit: >N messages in window blocked
- Spam: repeated characters/messages blocked
- Edge cases: empty string, unicode, very long messages
- Messages send and appear on other client
- Encrypted messages unreadable in Supabase dashboard
- HTML tags in messages are escaped (no XSS)
- Nickname displays correctly
- Connection/disconnection handled gracefully

**Pass criteria:** Two browser tabs can chat, messages encrypted, automod filters bad words

---

### Phase 2: Jarvis Voice Command Integration

**Steps:**
1. Add `_is_chat_command(text)` function in `main.py`:
   - Matches: "open chat", "launch chat", "start chat", "livechat", "live chat", "open livechat"
2. Add handler in chat mode processing (alongside game handlers, ~line 735-799)
3. Add handler in PTT mode processing (alongside game handlers, ~line 995-1070)
4. Both call `send_chat_iframe_fullscreen()` with local `chat.html` path

**Files modified:**
- `main.py` (~20 lines added)

**Test:** Integration test (similar to existing `test_game_windows.py` pattern)
- Voice text "open chat" triggers chat iframe
- Voice text "launch chat" triggers chat iframe
- Voice text "start livechat" triggers chat iframe
- Unrelated text does NOT trigger chat
- Chat iframe loads without error

**Pass criteria:** `python -m pytest test_chat_command.py` — all pass

---

### Phase 3: Supabase Project Setup

**Steps:**
1. Create free Supabase project for livechat
2. Get publishable anon key and project URL
3. Wire into chat.html configuration
4. Verify Realtime Broadcast works end-to-end
5. Document setup steps for anyone who wants their own Supabase project (customization)

**Files modified:**
- `chat.html` (add Supabase config)

**Test:** End-to-end flow
- Open chat.html in two browsers
- Send message from A, appears in B (encrypted + decrypted)
- Send banned word from A, filtered on B
- Check Supabase dashboard — messages are encrypted blobs, not readable
- Verify no IP leakage (browser network tab shows only supabase.co connections)

**Pass criteria:** Full end-to-end encrypted chat working between two clients

---

### Phase 4: Polish and Edge Cases

**Steps:**
1. Graceful handling: Supabase disconnection, reconnection, quota exhaustion
2. "No one here" empty state
3. Auto-scroll, message timestamps, character limit
4. Responsive layout that works in Jarvis iframe dimensions
5. Ensure all styling matches Jarvis design system (see Design System section above)
6. Add customization hooks: room name input, ban word editor

**Files modified:**
- `chat.html`

**Test:** Edge case validation
- Disconnect wifi → reconnects when restored
- Send message while disconnected → queued or error shown
- 200+ character message → truncated with indicator
- Rapid messages → rate limited with feedback
- Empty message → send button disabled

**Pass criteria:** All edge cases handled gracefully, no crashes or hangs

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Supabase free tier quota exhaustion | Medium — chat down for month | Create new project in 2 min, update config |
| Supabase changes free tier pricing | High — need new relay | Fallback: Open Relay TURN + Trystero P2P approach |
| XSS via chat messages | High | All text rendered via textContent. No innerHTML. No user HTML. |
| Spam flooding | Medium | Receiver-side automod + rate limiting. Ephemeral = no permanent damage. |

## Rollback Plan

- **Phase 1**: Delete `chat.html`. Zero impact on existing code.
- **Phase 2**: Remove ~20 lines from `main.py`. Trivial revert.
- **Phase 3**: Delete Supabase project. Free, instant.
- **Full rollback**: `git revert` single commit per phase. Each phase is independently revertable.

## Success Criteria

- [ ] Two clients can chat in real-time via local chat.html
- [ ] Messages are E2E encrypted (verified in Supabase dashboard)
- [ ] Automod blocks banned keywords on receiver side
- [ ] Rate limiting prevents spam flooding
- [ ] "open chat" voice command launches chat iframe in Jarvis
- [ ] Zero cost — only Supabase free tier used
- [ ] No peer IP exposure — only supabase.co in network tab
- [ ] All text HTML-escaped — no XSS possible

## Approval

- [x] User approved this plan
- [x] Revision v2 approved (Rust WASM → JS automod simplification)
