# PLAN: Livechat v2 — Full Rewrite

Date: 2026-02-26
Status: Complete

## Problems with v1

1. **file:// srcdoc path breaks keyboard** — Metal app base64-encodes the HTML into an iframe srcdoc. `forwardKeyToIframe()` dispatches raw KeyboardEvents but never inserts text into form inputs. Fundamentally broken for any page with text inputs.
2. **No secure context** — file:// is not a secure context. `crypto.subtle` and `crypto.randomUUID()` unavailable. Had to add plaintext fallback hacks.
3. **Forced "Agent-XXXX" names** — Random default, no persistence, no way to change after joining. localStorage doesn't persist across srcdoc reloads.
4. **Connection unreliable** — No timeout on initial connect. Silent failures. User sees "connecting" forever with no feedback.
5. **Performance** — Entire HTML file base64-encoded, decoded, injected as srcdoc. Wasteful.
6. **Keyboard interceptor hack** — Had to add 50 lines of JS to manually parse keyCode and insert characters. Brittle, incomplete (no paste, no IME, no selection).

## Root Cause

All issues stem from one decision: loading chat.html via `file://` → triggers the srcdoc iframe path in `ChatWebView+Fullscreen.swift`.

The **navigated** path (`http(s)://` URLs) has none of these problems:
- `forwardKeyToNavigated()` has full text input handling (character insertion, backspace, enter, paste, arrow keys, selection)
- Secure context on localhost → crypto.subtle works
- localStorage persists per origin
- No base64 encoding overhead

## Solution

Serve chat.html via a local HTTP server. Pass `http://localhost:PORT/chat.html` instead of `file://...`. The Metal app routes this through the navigated fullscreen path.

```
Before:  file://chat.html → srcdoc iframe → broken keyboard, no crypto
After:   http://localhost:PORT/chat.html → navigated WKWebView → everything works
```

## Architecture

```
main.py
  ├─ Starts local HTTP server (daemon thread, port 19847)
  │   └─ Serves chat.html from JARVIS_DIR
  ├─ Voice command "open chat"
  │   └─ metal.send_chat_iframe_fullscreen("http://localhost:19847/chat.html")
  │       → Swift navigated path → forwardKeyToNavigated() → proper keyboard
  └─ chat.html
       ├─ Supabase Realtime Broadcast (message relay)
       ├─ Web Crypto AES-GCM (works on localhost secure context)
       ├─ AutoMod (keyword filter, rate limit, spam detection)
       ├─ localStorage nickname persistence (works on localhost origin)
       └─ Nick change via header click
```

## Implementation Phases

### Phase 1: Local HTTP Server in main.py

Add a minimal static file server that starts once on first chat launch.

- Steps:
  - Add `_chat_server_started` flag and `CHAT_SERVER_PORT = 19847` constant
  - Add `_start_chat_server()` function using `http.server` in a daemon thread
  - Serves only from JARVIS_DIR, only `chat.html` (reject other paths)
  - Call `_start_chat_server()` before launching chat URL
  - Change both handlers (chat-input + PTT) to use `http://localhost:19847/chat.html`
  - Remove the keyboard interceptor hack from chat.html
- Test: Server starts, GET /chat.html returns 200, GET /anything-else returns 404
- Pass criteria: `pytest test_chat_server.py -v` all pass

### Phase 2: Fix chat.html for navigated context

Strip all the srcdoc workarounds. Use proper web APIs now available on localhost.

- Steps:
  - Remove `crypto.randomUUID()` fallback — just use it (secure context)
  - Remove `Crypto._plaintextMode` and plaintext fallback — encrypt always works
  - Remove the entire "SRCDOC IFRAME KEYBOARD INTERCEPTOR" block
  - Remove `-webkit-user-select: text` hacks on inputs (not needed in navigated)
  - Remove `user-select: none` from body entirely (not needed)
  - Use `localStorage` for nickname persistence:
    - On load: read `jarvis-chat-nick` from localStorage, pre-fill input
    - On join: save nick to localStorage
    - On change: update localStorage
  - Allow any nickname (remove forced "Agent-" prefix), 1-20 chars
  - Add nick validation: alphanumeric + spaces + dashes + underscores only
  - Moderate nick through automod on join AND on change
  - Show nick in header, clickable to change
  - Add connection timeout (10s) — show error if Supabase doesn't connect
  - Add "Retry" button on connection failure
- Test: localStorage persistence works, nick change works, crypto always encrypts, no plaintext fallback code present
- Pass criteria: `pytest test_chat_command.py -v` all pass, manual verify in app

### Phase 3: Update tests + cleanup

- Steps:
  - Update `test_chat_command.py` to remove placeholder config check (no more `YOUR_SUPABASE_URL_HERE`)
  - Add test for chat server (port, response, 404 on other paths)
  - Remove stale comments referencing srcdoc/file:// workarounds
  - Update PLAN status
- Test: All tests pass
- Pass criteria: `pytest test_chat_command.py test_chat_server.py -v` all pass

## Risks & Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Port 19847 already in use | Chat won't load | Try port, if taken try 19848-19857, log which port was used |
| Server thread crashes | Chat stops working | Daemon thread — app keeps running. Can restart server on next chat command |
| Someone on LAN hits localhost:19847 | Reads chat.html source | HTML is public anyway (no secrets). Anon key is publishable by design |

## Rollback Plan

Revert to file:// path in main.py handlers. The srcdoc path still works (with the keyboard hack) as a fallback.

## Success Criteria

- [ ] Typing works natively (no keyboard interceptor hack)
- [ ] Backspace, paste (Cmd+V), arrow keys all work
- [ ] Nicknames persist across sessions via localStorage
- [ ] Nicknames changeable by clicking header
- [ ] E2E encryption always active (no plaintext fallback)
- [ ] Connection shows clear error on failure with retry option
- [ ] All tests pass
