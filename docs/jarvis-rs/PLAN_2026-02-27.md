# PLAN: Jarvis v2 — Full Rust Rewrite

Date: 2026-02-27
Status: Draft

## Overview

Complete rewrite of Jarvis from Python + Swift/Metal to a single Rust binary. Jarvis v2 is a **custom social tiling terminal emulator** for vibe coders and coding creators. It combines:

- GPU-rendered terminal emulator
- Tiling window manager (own panes + external applications)
- AI coding assistant (Claude Code + Gemini, native Rust HTTP — no Python)
- Social platform (presence, chat, channels, threads)
- Pair programming (shared terminals, cursor sharing)
- Games and rich web content (via embedded WebView)
- Fully customizable via YAML/TOML config

**Target platforms:** macOS, Linux (X11 + Wayland), Windows
**Distribution:** Single binary per platform
**Ship strategy:** Big bang — full feature set before v1 release

### v1 vs v2 Feature Scope

| Feature | v1 (Ship) | v2 (Feature-flagged) |
|---------|-----------|---------------------|
| Terminal emulator | Yes | — |
| Tiling window manager | Yes | — |
| AI engine (Claude, Gemini, Whisper) | Yes | — |
| Social (presence, text chat, channels) | Yes | — |
| Pair programming (shared terminal) | Yes (WebSocket) | WebRTC data channels |
| Voice chat | No | `#[cfg(feature = "voice")]` |
| Screen sharing | No | `#[cfg(feature = "screen-share")]` |
| Games / WebView | Yes | — |
| Config / themes / keybinds | Yes | — |

## Context

Current Jarvis is Python backend (AI, voice, presence) + Swift/Metal frontend communicating via JSON over stdin/stdout. This architecture has served us well for prototyping but has fundamental limitations:

1. **macOS-only** — Swift/Metal locks us to Apple
2. **Two-process model** — IPC overhead, deployment complexity, crash isolation issues
3. **Python performance** — GIL, startup time, dependency management
4. **No external app tiling** — current UI is a single fullscreen window with embedded web views

The Rust rewrite solves all of these while preserving every feature and adding new capabilities.

## Decisions (Locked)

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Social scope | Full (existing + Discord-lite + pair programming) | Core differentiator |
| Web content | Hybrid (native Rust UI + WebKit for rich content) | Balance effort vs capability |
| Platform | Cross-platform (macOS, Linux, Windows) | Maximum reach from day one |
| AI backend | Full Rust rewrite (HTTP APIs directly) | Zero Python dependency, single binary |
| MVP scope | All features before v1 (voice/screen-share feature-flagged) | Big bang ship |
| Ship strategy | Big bang — build all, ship once | Full vision on day one |
| Chat backend | Supabase Realtime (port from existing Python/JS) | Already working, free tier, ephemeral |
| Voice/Screen share | Feature-flagged out of v1 | WebRTC immaturity, reduces attack surface |

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Jarvis v2 (Single Rust Binary)                │
├─────────────┬──────────────┬──────────────┬─────────────────────┤
│   Tiling    │   Terminal   │    Social    │     AI Engine       │
│   Manager   │   Emulator   │    Engine    │                     │
│             │              │              │                     │
│ Platform    │ PTY/ConPTY   │ Supabase RT  │ Claude HTTP API     │
│ Abstraction │ VTE parser   │ Presence     │ Gemini HTTP API     │
│ Trait:      │ Unicode/     │ Chat/Channel │ Whisper HTTP API    │
│  macOS: AX  │  grapheme    │ Pair prog    │ Tool execution      │
│  Linux: X11/│ Scrollback   │ Identity     │ Streaming           │
│   Wayland   │ Selection    │              │ Function calling    │
│  Win: Win32 │ Search       │ ┌──────────┐ │ Conversation mgmt   │
│             │              │ │FEAT-FLAG │ │                     │
│             │              │ │Voice chat│ │                     │
│             │              │ │Screen shr│ │                     │
│             │              │ └──────────┘ │                     │
├─────────────┴──────────────┴──────────────┴─────────────────────┤
│                       wgpu Renderer                              │
│  Text (glyphon/cosmic-text) │ UI Chrome │ Backgrounds │ Effects │
├──────────────────────────────────────────────────────────────────┤
│                     wry WebView Bridge                           │
│          (Games, Rich Content, Iframe Embeds)                    │
├──────────────────────────────────────────────────────────────────┤
│                    Platform Abstraction Layer                     │
│  Window Mgmt │ Clipboard │ Notifications │ File Paths           │
├──────────────────────────────────────────────────────────────────┤
│                    Config System (YAML/TOML)                     │
│  Live reload │ Themes │ Keybinds │ Semantic Colors │ Validation │
└──────────────────────────────────────────────────────────────────┘
```

### Platform Abstraction — External App Tiling

The tiling manager must control external application windows on all 3 platforms. Each has a completely different API:

```rust
/// Platform-agnostic trait for controlling external application windows
pub trait WindowManager: Send + Sync {
    /// Enumerate all visible windows
    fn list_windows(&self) -> Result<Vec<ExternalWindow>>;
    /// Move and resize a window to a specific frame
    fn set_window_frame(&self, window_id: WindowId, frame: Rect) -> Result<()>;
    /// Focus a window
    fn focus_window(&self, window_id: WindowId) -> Result<()>;
    /// Minimize / restore
    fn set_minimized(&self, window_id: WindowId, minimized: bool) -> Result<()>;
    /// Subscribe to window creation/destruction/move events
    fn watch_windows(&self, callback: Box<dyn Fn(WindowEvent) + Send>) -> Result<WatchHandle>;
}
```

| Platform | Implementation | Crate/API |
|----------|---------------|-----------|
| macOS | `MacWindowManager` | `core-foundation`, `accessibility` crate (AXUIElement FFI) |
| Linux X11 | `X11WindowManager` | `x11rb` crate (XCB bindings) |
| Linux Wayland | `WaylandWindowManager` | `wayland-client` + compositor-specific protocols (wlr-foreign-toplevel) |
| Windows | `Win32WindowManager` | `windows` crate (Win32 `SetWindowPos`, `EnumWindows`) |

**Wayland caveat:** Wayland intentionally restricts window management. We'll need compositor-specific protocols (wlr-foreign-toplevel-management for wlroots-based compositors like Sway/Hyprland). GNOME/KDE may have limited support. This is a known limitation we accept.

### Platform Abstraction — File Paths

| Platform | Config Dir | Data Dir | Cache Dir |
|----------|-----------|----------|-----------|
| macOS | `~/Library/Application Support/jarvis` | Same | `~/Library/Caches/jarvis` |
| Linux | `$XDG_CONFIG_HOME/jarvis` (~/.config/jarvis) | `$XDG_DATA_HOME/jarvis` | `$XDG_CACHE_HOME/jarvis` |
| Windows | `%APPDATA%\jarvis` | `%LOCALAPPDATA%\jarvis` | `%LOCALAPPDATA%\jarvis\cache` |

Use `dirs` crate for platform-correct paths.

## Crate Dependencies (Core)

| Domain | Crate | Purpose | v1 | Feature-flag |
|--------|-------|---------|----|----|
| **Window/Event** | `winit` | Cross-platform window creation, event loop | Yes | — |
| **GPU Render** | `wgpu` | Cross-platform GPU (Metal/Vulkan/DX12) | Yes | — |
| **Text Render** | `cosmic-text` | Font shaping, layout, rasterization | Yes | — |
| **Text Render** | `glyphon` | wgpu text rendering (uses cosmic-text) | Yes | — |
| **Terminal** | `alacritty_terminal` (or custom) | VTE parsing, grid, scrollback | Yes | — |
| **PTY** | `portable-pty` | Cross-platform PTY (Unix pty + Windows ConPTY) | Yes | — |
| **WebView** | `wry` | Embedded WebView (WebKit/WebKitGTK/WebView2) | Yes | — |
| **Windowing** | `tao` | Window management (wry's companion, fork of winit) | Yes | — |
| **HTTP Client** | `reqwest` | AI API calls (Claude, Gemini, Whisper) | Yes | — |
| **WebSocket** | `tokio-tungstenite` | Social/presence connections | Yes | — |
| **WebRTC** | `webrtc` (pion port) or `libwebrtc` FFI | Voice chat, screen sharing | No | `voice`, `screen-share` |
| **Audio** | `cpal` | Cross-platform audio capture/playback | No | `voice` |
| **Async Runtime** | `tokio` | Async I/O, networking, timers | Yes | — |
| **Serialization** | `serde` + `serde_json` + `serde_yaml` + `toml` | Config, API payloads | Yes | — |
| **Config Watch** | `notify` | File system watcher for live reload | Yes | — |
| **Logging** | `tracing` + `tracing-subscriber` | Structured logging | Yes | — |
| **Crypto** | `ring` or `rustls` | TLS, token generation, message signing | Yes | — |
| **Platform Dirs** | `dirs` | XDG/AppData/Library paths | Yes | — |
| **UUID** | `uuid` | Correlation IDs, session IDs | Yes | — |
| **Clipboard** | `arboard` | Cross-platform clipboard | Yes | — |
| **Image** | `image` | Background image loading | Yes | — |
| **Regex** | `regex` | Search, pattern matching | Yes | — |
| **SQLite** | `rusqlite` | Token tracking, message history cache | Yes | — |
| **Supabase** | `reqwest` + custom client | Realtime Broadcast + Presence API | Yes | — |

## Workspace Structure

```
jarvis-rs/
├── Cargo.toml                    # Workspace root
├── Cargo.lock
├── .github/
│   └── workflows/
│       ├── ci.yml                # Build + test on all 3 platforms
│       └── release.yml           # Binary releases per platform
│
├── crates/
│   ├── jarvis-app/               # Binary crate — main entry point
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── main.rs           # Entry point, event loop, startup
│   │       └── cli.rs            # CLI argument parsing
│   │
│   ├── jarvis-config/            # Config system (port from Python Phases 1-4)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── schema.rs         # Config struct definitions (typed)
│   │       ├── toml_loader.rs    # TOML loading with defaults
│   │       ├── theme.rs          # Theme import/resolution/merging
│   │       ├── colors.rs         # ANSI 16 + 256 indexed + semantic colors
│   │       ├── keybinds.rs       # Keybind parsing and mapping
│   │       ├── watcher.rs        # File watcher with debouncing
│   │       ├── reload.rs         # Live reload manager
│   │       └── validation.rs     # Schema validation
│   │
│   ├── jarvis-terminal/          # Terminal emulator core
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── pty.rs            # PTY management (portable-pty)
│   │       ├── vte.rs            # VTE parser / terminal grid
│   │       ├── scrollback.rs     # Scrollback buffer
│   │       ├── selection.rs      # Text selection
│   │       ├── search.rs         # Terminal search
│   │       └── shell.rs          # Shell detection and launch
│   │
│   ├── jarvis-tiling/            # Tiling window manager
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── layout.rs         # Layout engine (splits, stacks, tabs)
│   │       ├── tree.rs           # Layout tree data structure
│   │       ├── pane.rs           # Pane abstraction (terminal, webview, external)
│   │       ├── commands.rs       # Tiling commands (split, close, resize, swap)
│   │       └── platform/
│   │           ├── mod.rs        # WindowManager trait
│   │           ├── macos.rs      # AXUIElement implementation
│   │           ├── x11.rs        # X11 implementation
│   │           ├── wayland.rs    # Wayland implementation
│   │           └── windows.rs    # Win32 implementation
│   │
│   ├── jarvis-renderer/          # wgpu rendering engine
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── gpu.rs            # wgpu device/surface setup
│   │       ├── text.rs           # Text rendering (glyphon/cosmic-text)
│   │       ├── ui.rs             # UI chrome (borders, tabs, status bar)
│   │       ├── background.rs     # Background modes (solid, gradient, hex grid, image)
│   │       ├── effects.rs        # Subtle GPU effects (glow, blur, scanlines)
│   │       ├── shaders/          # WGSL shaders
│   │       │   ├── background.wgsl
│   │       │   ├── text.wgsl
│   │       │   └── effects.wgsl
│   │       └── atlas.rs          # Glyph atlas management
│   │
│   ├── jarvis-ai/                # AI engine (Claude, Gemini, Whisper)
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── claude.rs         # Claude API client (streaming, tools, agents)
│   │       ├── gemini.rs         # Gemini API client (routing, function calling)
│   │       ├── whisper.rs        # Whisper API client (transcription)
│   │       ├── router.rs         # Intent detection and skill routing
│   │       ├── tools.rs         # Tool definitions and dispatch
│   │       ├── session.rs        # Conversation session management
│   │       ├── streaming.rs      # SSE/streaming response handling
│   │       └── token_tracker.rs  # Usage tracking (SQLite)
│   │
│   ├── jarvis-social/            # Social engine
│   │   ├── Cargo.toml            # voice + screen-share behind feature flags
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── presence.rs       # Presence system (online/offline/activity)
│   │       ├── chat.rs           # Direct messages + channel messages
│   │       ├── channels.rs       # Channel/thread system
│   │       ├── identity.rs       # Machine identity + message signing
│   │       ├── crypto.rs         # E2E encryption (DH for DMs, shared key for channels)
│   │       ├── protocol.rs       # Wire protocol (WebSocket + Supabase messages)
│   │       ├── supabase.rs       # Supabase Realtime client (broadcast + presence)
│   │       ├── moderation.rs     # Server-side rate limiting + spam detection
│   │       ├── pair.rs           # Pair programming (shared terminal, cursors)
│   │       ├── voice.rs          # [feature = "voice"] Voice chat (WebRTC)
│   │       └── screen_share.rs   # [feature = "screen-share"] Screen sharing
│   │
│   ├── jarvis-webview/           # WebView bridge for rich content
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── bridge.rs         # Rust ↔ WebView IPC
│   │       ├── content.rs        # Content loading (games, chat HTML)
│   │       └── security.rs       # Content security policy, sandboxing
│   │
│   ├── jarvis-platform/          # Platform abstraction layer
│   │   ├── Cargo.toml
│   │   └── src/
│   │       ├── lib.rs
│   │       ├── clipboard.rs      # arboard wrapper
│   │       ├── notifications.rs  # Native notifications
│   │       ├── paths.rs          # Platform-correct config/data/cache dirs
│   │       └── keymap.rs         # Platform-aware key mapping (Cmd vs Ctrl)
│   │
│   └── jarvis-common/            # Shared types, utilities
│       ├── Cargo.toml
│       └── src/
│           ├── lib.rs
│           ├── types.rs          # Shared type definitions
│           ├── errors.rs         # Error types (thiserror)
│           ├── events.rs         # Event bus / message passing
│           └── id.rs             # ID generation (UUID, correlation IDs)
│
├── resources/
│   ├── config.default.toml       # Default config (port from current)
│   ├── themes/                   # Theme files (port from current)
│   │   ├── jarvis-dark.yaml
│   │   ├── jarvis-light.yaml
│   │   ├── nord.yaml
│   │   ├── dracula.yaml
│   │   ├── catppuccin-mocha.yaml
│   │   ├── tokyo-night.yaml
│   │   ├── gruvbox-dark.yaml
│   │   └── solarized-dark.yaml
│   ├── games/                    # HTML games (preserved as-is)
│   │   ├── asteroids.html
│   │   ├── tetris.html
│   │   ├── minesweeper.html
│   │   ├── doodlejump.html
│   │   ├── subway.html
│   │   ├── pinball/
│   │   ├── draw.html
│   │   └── videoplayer.html
│   ├── web/                      # Web content
│   │   ├── chat.html             # Livechat (port from current)
│   │   └── settings.html         # Settings UI
│   └── fonts/                    # Bundled fonts (fallback)
│       └── JetBrainsMono/
│
└── tests/
    ├── integration/              # Cross-crate integration tests
    └── fixtures/                 # Test data
```

## Implementation Phases

Every phase builds on the previous. Nothing ships until all phases are complete.
Each phase MUST have passing tests before moving to the next.

---

### Phase 1: Foundation — Workspace, Config, Platform Layer

**Goal:** Rust workspace compiles, config system works, platform abstractions defined.

**Steps:**
1. Initialize Cargo workspace with all crate stubs
2. Port `jarvis-config` from Python (Phases 1-4 code):
   - TOML loading with schema validation
   - Theme import/resolution/merging
   - ANSI 16 + 256 indexed + semantic color system
   - Live reload with file watcher + debouncing
   - Keybind parsing
3. Implement `jarvis-platform`:
   - Platform-correct paths (dirs crate)
   - Clipboard abstraction (arboard)
   - Key mapping (Cmd/Ctrl/Super normalization)
4. Implement `jarvis-common`:
   - Error types (thiserror)
   - Event bus (tokio broadcast channels)
   - ID generation
5. Define all trait interfaces (not implementations yet):
   - `WindowManager` trait in jarvis-tiling
   - AI client traits in jarvis-ai

**Test:**
- Unit tests for config loading, theme merging, color resolution
- Unit tests for platform path resolution (per-platform)
- Config validation rejects invalid input
- File watcher detects changes and triggers reload
- Port all 67 existing Python config tests to Rust

**Pass criteria:** `cargo test --workspace` passes, `cargo clippy -- -D warnings` clean

---

### Phase 2: Terminal Emulator Core

**Goal:** A working terminal emulator that can run a shell.

**Steps:**
1. Implement `jarvis-terminal`:
   - PTY spawning via `portable-pty` (Unix pty + Windows ConPTY)
   - Shell detection (SHELL env on Unix, cmd/powershell on Windows)
   - VTE parser integration (evaluate: `vte` crate, `alacritty_terminal`, or custom)
   - Terminal grid with cell attributes (fg, bg, bold, italic, underline, etc.)
   - Scrollback buffer (configurable size from config)
   - UTF-8 / Unicode / grapheme cluster support
   - Text selection (mouse + keyboard)
   - Terminal search (regex + literal)
   - Copy/paste via platform clipboard

**Test:**
- VTE parsing: ANSI escape sequences produce correct grid state
- PTY: shell spawns and receives input, produces output
- Scrollback: buffer respects size limit, wraps correctly
- Selection: mouse coordinates map to correct cells
- Search: finds matches, highlights, cycles through results
- Unicode: CJK double-width, emoji, combining characters render correctly
- Cross-platform: ConPTY works on Windows, pty works on Unix

**Pass criteria:** `cargo test -p jarvis-terminal` passes, can programmatically run `echo hello` and verify output in grid

---

### Phase 3: GPU Renderer

**Goal:** wgpu renders terminal text and UI chrome to a window.

**Steps:**
1. Implement `jarvis-renderer`:
   - wgpu device/surface initialization (auto-select backend per platform)
   - Glyph atlas with `cosmic-text` for shaping + `glyphon` for GPU rendering
   - Terminal grid rendering (cells -> textured quads)
   - Cell background colors
   - Cursor rendering (block, underline, bar — configurable)
   - UI chrome: borders, tab bar, status bar, pane dividers
   - Background modes: solid color, gradient, hex grid animation, image
   - Subtle effects: glow on active pane, dim on inactive
2. Window creation with `winit` (or `tao` if using wry):
   - Fullscreen and windowed modes
   - Resize handling (recalculate grid dimensions)
   - HiDPI / scale factor support
   - Platform-specific window chrome (or borderless)

**Test:**
- wgpu initializes on each platform without panic
- Font atlas loads system fonts, falls back to bundled font
- Grid rendering: NxM cells drawn at correct positions
- Resize: grid recalculates, no visual artifacts
- Background modes: each mode renders without artifacts
- HiDPI: text is sharp at 2x scale factor
- Benchmark: 60fps with 200-line terminal output (measured)

**Pass criteria:** `cargo test -p jarvis-renderer` passes, visual smoke test shows terminal grid with text

---

### Phase 4: Tiling Layout Engine + External App Management

**Goal:** Split panes, resize, navigate. Tile external application windows.

**Steps:**
1. Implement `jarvis-tiling` layout engine:
   - Binary tree layout (horizontal/vertical splits)
   - Stack layout (tabbed panes)
   - Pane types: Terminal, WebView, ExternalApp
   - Commands: split-horizontal, split-vertical, close, resize, swap, focus-next, focus-prev, focus-direction
   - Configurable gaps between panes
   - Min/max pane size constraints
   - Zoom (one pane fullscreen, toggle back)
2. Implement platform WindowManager:
   - macOS: `MacWindowManager` using `AXUIElement` FFI
   - Linux X11: `X11WindowManager` using `x11rb`
   - Linux Wayland: `WaylandWindowManager` (wlr-foreign-toplevel, graceful fallback)
   - Windows: `Win32WindowManager` using `windows` crate
3. Integration: tiling layout drives both internal panes and external windows

**Test:**
- Layout: binary tree produces correct rectangles for N splits
- Layout: resize a divider redistributes space correctly
- Layout: close pane promotes sibling
- Layout: zoom/unzoom preserves original layout
- Platform (macOS): can enumerate windows, move a window to target rect
- Platform (Linux X11): same
- Platform (Windows): same
- Integration: mixed pane types (terminal + external) tile correctly

**Pass criteria:** `cargo test -p jarvis-tiling` passes, integration test demonstrates terminal + external app tiled side by side

---

### Phase 5: WebView Bridge

**Goal:** Embed web content (games, rich chat, settings) in panes.

**Steps:**
1. Implement `jarvis-webview`:
   - `wry` integration for embedded WebView in tiling panes
   - Rust <-> WebView IPC (JavaScript `window.ipc.postMessage` -> Rust handler)
   - Content loading from bundled resources (games, chat HTML)
   - URL loading for iframes (YouTube, etc.)
   - Content Security Policy enforcement
   - Ad blocking (URL filter list)
2. Port HTML games:
   - Verify all games work in embedded WebView
   - Add IPC hooks for game events (score, state) -> Rust
3. Settings UI:
   - Port HTML/CSS/JS, wire IPC to config system
   - Theme preview via CSS variable injection

**Test:**
- WebView creates and renders HTML content
- IPC: Rust sends message -> JS receives, JS sends message -> Rust receives
- Games: each game loads without errors
- CSP: blocked resources are actually blocked
- Security: no access to local filesystem from WebView

**Pass criteria:** `cargo test -p jarvis-webview` passes, games playable in embedded pane

---

### Phase 6: AI Engine

**Goal:** Claude Code, Gemini routing, and Whisper transcription — all native Rust HTTP.

**Steps:**
1. Implement `jarvis-ai` Claude client:
   - Anthropic Messages API via `reqwest`
   - SSE streaming response parsing
   - Tool use (function calling)
   - Claude Agent SDK equivalent (multi-turn with tool loops)
   - Conversation management (history, context window, pruning)
   - Sub-agent spawning
   - Approval gate for dangerous tool calls
2. Implement Gemini client:
   - Google AI Studio / Vertex API via `reqwest`
   - Streaming response parsing
   - Function calling for intent detection (port SkillRouter logic)
   - Model routing (Flash for routing, Pro for complex tasks)
3. Implement Whisper client:
   - OpenAI Whisper API via `reqwest`
   - Audio capture -> transcription pipeline
4. Implement router:
   - Voice input -> Whisper -> text
   - Text -> Gemini Flash intent detection -> skill routing
   - Skill execution -> Claude Code / Gemini Pro
   - Tool dispatch (file ops, bash, search)
   - Per-panel session management (up to 5 panels)
5. Token tracking:
   - SQLite-based usage tracking (rusqlite)
   - Per-model, per-session cost tracking

**Test:**
- Claude: mock server, verify streaming parsing, tool use round-trip
- Gemini: mock server, verify function calling, intent detection
- Whisper: mock server, verify audio -> text pipeline
- Router: intent "open a terminal" routes to correct handler
- Tool dispatch: file read/write/search tools execute correctly
- Token tracker: records usage, calculates costs correctly
- Error handling: API timeout -> retry -> circuit break -> user error message

**Pass criteria:** `cargo test -p jarvis-ai` passes, integration test demonstrates voice -> intent -> AI response -> tool execution -> result

---

### Phase 7: Social Engine — Presence, Chat & Security

**Goal:** Port presence system and Supabase chat with proper security hardening.

**Backend:** Reuse existing Supabase Realtime (broadcast + presence) and presence server (`wss://jarvis-presence-*.run.app`).

**Steps:**

1. Implement Supabase Realtime client (`supabase.rs`):
   - WebSocket connection to Supabase Realtime API
   - Broadcast: send/receive encrypted messages on `jarvis-livechat` channel
   - Presence: track/untrack users, sync presence state
   - Connection management: timeout, exponential backoff reconnect (max 8 attempts)

2. Implement identity system with cryptographic signing (`identity.rs`):
   - **[SECURITY: P0]** Persistent machine identity from `~/.jarvis/identity.json` (port from Python)
   - Generate Ed25519 keypair per machine on first run
   - Sign all outbound messages with machine private key
   - Verify inbound message signatures against known public keys
   - Identity stored in native filesystem — NEVER in WebView localStorage
   - Display name: hostname-derived, user-customizable

3. Implement E2E encryption (`crypto.rs`):
   - **[SECURITY: P1]** DMs: X25519 Diffie-Hellman key exchange per conversation pair
   - Channels: AES-GCM-256 with room-derived key (port from existing PBKDF2 derivation)
   - Per-message random 12-byte IV
   - **[SECURITY: P2]** Message replay protection: monotonic sequence numbers per sender
   - Key rotation on channel membership changes

4. Implement presence (`presence.rs`):
   - WebSocket client to existing presence server (tokio-tungstenite)
   - Heartbeat, reconnection with exponential backoff
   - Activity updates (coding, in-game, idle, etc.)
   - User list with status
   - Grace period for reconnects (don't show offline immediately)

5. Implement chat (`chat.rs`):
   - Direct messages (1:1) with per-pair E2E encryption
   - Message history: local SQLite cache (optional, configurable)
   - Markdown rendering in terminal pane (not WebView)
   - Message notifications

6. Implement channels & threads (`channels.rs`):
   - Channel creation/joining/leaving
   - **[SECURITY: P2]** Channel access control: public, private (invite-only), DM
   - Thread replies
   - Channel list in sidebar pane
   - Unread indicators

7. Implement server-side moderation (`moderation.rs`):
   - **[SECURITY: P0]** Rate limiting enforced on presence server (not client-only)
   - Sliding window: max N messages per window per identity
   - Spam detection: repeated chars, repeated messages, keyword filter
   - Ban list by machine identity (not just nick)
   - **[SECURITY: P2]** Offline message queue with caps (100 messages, 24-hour TTL)

8. Implement pokes & game invites:
   - Port from current Python implementation
   - Desktop notifications (platform-native)

9. Port/update presence server:
   - Add channel/thread support to server protocol
   - Add server-side rate limiting
   - Maintain backward compatibility with current Python client

**Security measures (integrated, not afterthought):**
- ASCII-only nicknames with NFKC normalization (prevent Unicode lookalike impersonation)
- All message text rendered via `textContent` equivalent (no innerHTML, no XSS)
- Supabase anon key is publishable by design (same model as Stripe publishable keys)
- WebView never holds identity state — Rust owns identity, passes display-only data to WebView
- DOM message cap (500 messages) to prevent memory exhaustion

**Test:**
- Identity: keypair generated on first run, persists across restarts
- Identity: message signed -> verified by receiver -> accepted
- Identity: forged signature -> rejected
- Encryption: DM encrypted with DH key -> only participants can decrypt
- Encryption: channel message encrypted -> all channel members decrypt
- Replay: replayed message (duplicate sequence number) -> rejected
- WebSocket: connects, heartbeats, reconnects on disconnect
- Presence: status updates propagate to other clients
- Chat: send message -> other client receives and decrypts
- Channels: create, join, send message, leave
- Channels: private channel -> uninvited user cannot join
- Threads: reply to message, thread messages grouped correctly
- Rate limiting: exceeding limit -> messages rejected server-side
- Moderation: banned identity -> messages dropped
- Offline queue: > 100 messages -> oldest dropped
- Nick: Unicode lookalike nick -> normalized or rejected

**Pass criteria:** `cargo test -p jarvis-social` passes, integration test with 2 clients shows authenticated, encrypted real-time chat

---

### Phase 8: Voice Chat & Screen Sharing [FEATURE-FLAGGED — NOT IN v1]

**Status:** Stubbed. Trait definitions and module structure exist. All code behind `#[cfg(feature = "voice")]` and `#[cfg(feature = "screen-share")]`. No runtime code compiled into v1 binary.

**Goal (v2):** WebRTC-based voice and screen sharing for social and pair programming.

**Cargo.toml:**
```toml
[features]
default = []
voice = ["dep:cpal", "dep:opus", "dep:webrtc"]
screen-share = ["dep:webrtc"]

[dependencies]
cpal = { version = "0.15", optional = true }
opus = { version = "0.3", optional = true }
webrtc = { version = "0.11", optional = true }
```

**Stubbed modules (compile to nothing without feature flags):**

```rust
// voice.rs
#[cfg(feature = "voice")]
mod voice_impl;

#[cfg(feature = "voice")]
pub use voice_impl::*;

#[cfg(not(feature = "voice"))]
pub fn voice_available() -> bool { false }
```

```rust
// screen_share.rs
#[cfg(feature = "screen-share")]
mod screen_share_impl;

#[cfg(feature = "screen-share")]
pub use screen_share_impl::*;

#[cfg(not(feature = "screen-share"))]
pub fn screen_share_available() -> bool { false }
```

**When implementing (v2), address these security issues:**

1. **[P0] Authenticate WebRTC signaling** — Sign SDP offers/answers with identity keys. Only invited participants can exchange SDP with a session.
2. **[P0] Screen sharing safety** — Default to window-specific sharing. Persistent "SHARING" indicator. Warn before sharing terminal panes. Option to exclude panes.
3. **[P1] DTLS fingerprint verification** — Include DTLS fingerprints in signed signaling messages. Verify against expected peer identity.
4. **[P1] Mic-active visual indicator** — Always visible when audio capture is active. Log all capture start/stop.
5. **[P2] Zero frame buffers** — Wipe screen capture buffers after encoding. Use `mlock` to prevent swap. Disable core dumps during sharing.
6. **[P2] DTLS-SRTP on all data channels** — No fallback to unencrypted. Alert on negotiation failure.
7. **[P3] Opus frame validation** — Validate frame sizes before decoding. Max frame duration. Panic-safe decoder.
8. **[P3] Echo cancellation** — Enforce PTT-only if native AEC unavailable. Headphone detection if feasible.
9. **[P3] Call recording consent** — If ever added, require all-party notification.

**Steps (v2, not v1):**
1. Evaluate WebRTC approach:
   - Option A: `webrtc-rs` (pure Rust pion port)
   - Option B: `libwebrtc` FFI
   - Option C: WebRTC via embedded WebView (simplest fallback)
2. Implement voice chat (behind `voice` feature flag)
3. Implement screen sharing (behind `screen-share` feature flag)
4. Audio mixing, echo cancellation, noise suppression

**Pass criteria (v2):** `cargo test -p jarvis-social --features voice,screen-share` passes, manual test with 2 instances shows working voice chat

---

### Phase 9: Pair Programming

**Goal:** Shared terminals with cursor sharing and synchronized editing.

**Transport:** WebSocket via presence server (v1). WebRTC data channels when `voice` feature is enabled (v2).

**Steps:**
1. Shared terminal:
   - Host shares PTY output stream via WebSocket relay through presence server
   - Guest renders the same terminal grid
   - Guest can type (input sent to host, executed on host's PTY)
   - Read-only mode (guest can only watch)
   - Host controls permissions (can type / view only)
   - **[SECURITY]** All terminal I/O encrypted with session-specific key (derived via DH between host and guest)
2. Cursor sharing:
   - Each participant has a named, colored cursor
   - Cursor positions transmitted in real-time
   - Cursor labels (username) rendered near cursor
3. Session management:
   - Start/stop sharing a pane
   - Invite specific user (signed invite via identity system)
   - Session persists across layout changes
4. Conflict handling:
   - Simultaneous typing: both inputs sent to PTY (terminal handles naturally)
   - No OT/CRDT needed — it's a shared terminal, not a shared document

**Test:**
- Shared terminal: host types -> guest sees output
- Guest input: guest types -> host PTY receives -> both see result
- Read-only: guest input blocked when permission denied
- Cursor: host sees guest cursor at correct position
- Disconnect: guest disconnects -> host session continues normally
- Reconnect: guest reconnects -> catches up to current state
- **Security: terminal I/O encrypted end-to-end between host and guest**
- **Security: uninvited user cannot join pair session**

**Pass criteria:** `cargo test -p jarvis-social` (pair module) passes, integration test shows shared terminal working

---

### Phase 10: Input System & Keybinds

**Goal:** Comprehensive keyboard/mouse input handling, configurable keybinds.

**Steps:**
1. Input handling:
   - Keyboard events from winit/tao -> terminal input (with correct encoding)
   - Mouse events -> selection, clicks, scroll
   - Platform-aware modifier keys (Cmd on macOS, Ctrl on Linux/Windows)
   - IME support for CJK input
   - Bracketed paste mode
2. Keybind system:
   - Configurable keybinds from config (port keybind schema)
   - Modal keybinds (normal mode vs command mode)
   - Leader key support (e.g., `Ctrl+a` then `s` for split)
   - Keybind conflict detection
   - Default keybind set per platform
3. Command palette:
   - Fuzzy search over all commands
   - Recent commands
   - Rendered in wgpu (not WebView)

**Test:**
- Key events correctly encoded for terminal (CSI sequences, etc.)
- Mouse selection works across wrapped lines
- Keybind config parsed and applied correctly
- Leader key sequences fire correct command
- IME: can type CJK characters in terminal
- Command palette: fuzzy search returns correct results

**Pass criteria:** `cargo test` passes for input module, all keybinds from default config functional

---

### Phase 11: Polish & Integration

**Goal:** Everything wired together, polished, boot sequence, settings, error handling.

**Steps:**
1. Boot sequence:
   - Splash/loading animation (wgpu rendered)
   - Config load -> validate -> apply
   - Connect to presence server
   - Open default layout (configurable)
2. Settings UI:
   - All config sections editable (theme, font, keybinds, AI models, social)
   - Live preview for visual settings
   - Restart-required settings flagged
3. Error handling:
   - Panic hook -> graceful crash report
   - Per-subsystem error recovery (AI fails -> don't crash, show error in pane)
   - Crash report file with system info
4. Notifications:
   - In-app notification overlay
   - Platform-native notifications (optional, configurable)
5. Update system:
   - Version check against GitHub releases
   - Download + replace binary (or prompt user)
6. Performance:
   - Profile and optimize hot paths
   - 60fps at 4K with multiple terminal panes
   - < 500ms cold start
   - < 100MB RSS memory

**Test:**
- Boot: cold start -> functional in < 1 second
- Settings: change theme -> live update
- Crash: panic in AI module -> app continues, pane shows error
- Memory: no leaks after 1 hour of use (valgrind/instruments)
- Performance: 60fps benchmark with 4 terminal panes + 1 WebView

**Pass criteria:** All `cargo test --workspace` passes, `cargo clippy -- -D warnings` clean, manual smoke test on all 3 platforms

---

### Phase 12: Packaging & Distribution

**Goal:** Single binary per platform, CI/CD, installers.

**Steps:**
1. CI/CD (GitHub Actions):
   - Build matrix: macOS (arm64 + x86_64), Linux (x86_64, arm64), Windows (x86_64)
   - Run tests on all platforms
   - Clippy + fmt checks
   - Security audit (`cargo audit`)
2. Binary packaging:
   - macOS: `.app` bundle (via `cargo-bundle`) + Homebrew formula
   - Linux: AppImage + `.deb` + AUR package
   - Windows: `.exe` + installer (WiX or NSIS) + `winget` manifest
3. Auto-update:
   - GitHub Releases as update source
   - Signed binaries (if feasible)
4. Documentation:
   - README with install instructions per platform
   - Config documentation (generated from schema)
   - Keybind reference

**Test:**
- CI: all platform builds succeed
- Binary: runs on clean machine (no pre-installed dependencies)
- Package: macOS .app, Linux AppImage, Windows .exe all functional

**Pass criteria:** CI green on all platforms, binary tested on clean VM/container per platform

---

## Security Summary

### v1 Attack Surface (what ships)

| Surface | Mitigation |
|---------|------------|
| Supabase Realtime (chat relay) | Server-side rate limiting via presence server, not just client-side |
| Identity (impersonation) | Ed25519 signed messages, persistent machine keypair |
| Chat encryption (eavesdropping) | DH key exchange for DMs, shared AES-GCM for channels |
| Message replay | Monotonic sequence numbers per sender |
| WebView XSS | CSP enforcement, textContent only, identity never in WebView |
| Channel access | Public/private/DM types, invite-only for private |
| Nickname spoofing | ASCII-only + NFKC normalization, uniqueness per channel |
| Pair programming (terminal leak) | Session-specific DH encryption, signed invites |
| Free tier DoS | Messages relayed through presence server with enforced limits |

### v2 Attack Surface (feature-flagged, not yet active)

| Surface | Status |
|---------|--------|
| WebRTC signaling | Stubbed — will need signed SDP exchange |
| Audio capture | Stubbed — will need mic indicator + PTT enforcement |
| Screen capture | Stubbed — will need window-only default + sharing indicator |
| DTLS/SRTP | Stubbed — will need fingerprint verification |

## Risks & Mitigations

| Risk | Impact | Likelihood | Mitigation |
|------|--------|------------|------------|
| Scope too large, never ships | Critical | High | Strict phase discipline. Voice/screen-share feature-flagged out of v1. |
| WebRTC in Rust is immature | High | Medium | Feature-flagged to v2. Evaluate when ready. Fallback: WebView-based. |
| Wayland window management limited | Medium | High | Accept limitation. Document supported compositors. X11 fallback. |
| wgpu text rendering quality | Medium | Medium | Evaluate glyphon + cosmic-text in Phase 3. Fallback: swash. |
| Single developer velocity | High | High | v1 scope reduced by deferring voice/screen-share. |
| Platform-specific bugs | Medium | High | CI on all 3 platforms from Phase 1. |
| Supabase free tier exhaustion | Medium | Medium | Route through presence server with server-side limits. |

## Rollback Plan

The existing Python + Swift Jarvis remains functional throughout the rewrite. The rewrite is additive.

If the rewrite stalls:
1. Continue using current Jarvis
2. Cherry-pick improvements (config system is portable)
3. Evaluate descoping (e.g., drop pair programming, ship fewer platforms)

## Success Criteria

### v1
- [ ] Single Rust binary runs on macOS, Linux, and Windows
- [ ] Terminal emulator passes vttest basic suite
- [ ] Tiling manages 4+ terminal panes + 2 external app windows simultaneously
- [ ] AI assistant responds to voice and text input with Claude Code and Gemini
- [ ] Real-time chat between 2+ users with presence indicators
- [ ] Chat messages are end-to-end encrypted with verified identity
- [ ] Pair programming: shared terminal with cursor sharing
- [ ] All 8 games playable in WebView panes
- [ ] Config system: themes, keybinds, and settings fully customizable
- [ ] Live config reload works
- [ ] 60fps at 1080p with 4 terminal panes
- [ ] Cold start < 1 second
- [ ] No critical or high security findings from audit
- [ ] CI green on all 3 platforms

### v2 (future)
- [ ] Voice chat between 2+ users (feature flag enabled)
- [ ] Screen sharing functional (feature flag enabled)
- [ ] WebRTC signaling authenticated with identity keys

## Approval

- [ ] User approved this plan
