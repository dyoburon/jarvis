<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>JARVIS Livechat</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html { background: transparent !important; border-radius: var(--border-radius); overflow: hidden; }

body {
  background: var(--color-panel-bg);
  font-family: var(--font-ui);
  color: var(--color-text);
  height: 100vh;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  border: var(--border-width) solid var(--color-border);
  border-radius: var(--border-radius);
  transition: border-color var(--transition-speed) ease;
}

/* ================================================================ */
/* HEADER                                                           */
/* ================================================================ */

#header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 12px;
  border-bottom: var(--border-width) solid var(--color-border);
  min-height: 32px;
  flex-shrink: 0;
}

#header h1 {
  font-size: 12px;
  font-weight: 500;
  color: var(--color-text-muted);
  letter-spacing: 0.02em;
}

#header-meta {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 11px;
}

#close-btn {
  background: none;
  border: none;
  color: var(--color-text-muted);
  font-size: 16px;
  cursor: pointer;
  padding: 0 4px;
  line-height: 1;
  opacity: 0.4;
  transition: opacity var(--transition-speed) ease,
              color var(--transition-speed) ease;
}
#close-btn:hover {
  opacity: 1;
  color: var(--color-error);
}

#my-nick {
  color: var(--color-text);
  cursor: pointer;
  font-size: 11px;
  font-weight: 500;
}
#my-nick:hover {
  text-decoration: underline;
}

#status-dot {
  width: 5px;
  height: 5px;
  border-radius: 50%;
  background: var(--color-text-muted);
  display: inline-block;
  margin-right: 4px;
  transition: background var(--transition-speed) ease;
}

#status-dot.connected {
  background: var(--color-success);
}

#status-dot.connecting {
  background: var(--color-primary);
  animation: pulse 1.5s infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

#user-count {
  color: var(--color-text-muted);
  cursor: pointer;
  position: relative;
  transition: color 0.15s;
}
#user-count:hover {
  color: var(--primary);
}

/* ================================================================ */
/* ONLINE USERS DROPDOWN                                            */
/* ================================================================ */

#online-dropdown {
  display: none;
  position: absolute;
  top: 44px;
  right: 16px;
  background: rgba(13, 17, 23, 0.72);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  border-radius: 6px;
  min-width: 220px;
  max-height: 320px;
  overflow-y: auto;
  z-index: 20;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.6);
}
#online-dropdown.open { display: block; }
#online-dropdown::-webkit-scrollbar { width: 3px; }
#online-dropdown::-webkit-scrollbar-track { background: transparent; }
#online-dropdown::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 2px;
}

.dd-header {
  font-size: 10px;
  color: var(--color-text-muted);
  padding: 8px 12px 4px;
  text-transform: uppercase;
  letter-spacing: 1px;
  border-bottom: 1px solid var(--border);
}

.user-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  transition: background 0.15s;
}
.user-row:last-child { border-bottom: none; }
.user-row:hover { background: rgba(0, 212, 255, 0.03); }

.user-name {
  color: var(--primary);
  opacity: 0.65;
  font-size: 12px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.online-dot {
  display: inline-block;
  width: 5px;
  height: 5px;
  border-radius: 50%;
  background: var(--success);
  box-shadow: 0 0 4px rgba(0, 255, 136, 0.4);
  margin-right: 5px;
  vertical-align: middle;
}

.dd-empty {
  padding: 16px 12px;
  text-align: center;
  font-size: 11px;
  color: var(--color-text-muted);
  font-style: italic;
}

/* ================================================================ */
/* CHANNEL DROPDOWN                                                  */
/* ================================================================ */

#channel-title {
  cursor: pointer;
  user-select: none;
  display: flex;
  align-items: center;
  gap: 6px;
}
#channel-title:hover {
  text-shadow: 0 0 14px var(--glow-cyan);
}

.channel-chevron {
  font-size: 10px;
  opacity: 0.5;
  transition: transform 0.15s, opacity 0.15s;
}
#channel-title:hover .channel-chevron {
  opacity: 0.8;
}
#channel-title.open .channel-chevron {
  transform: rotate(180deg);
}

#channel-dropdown {
  display: none;
  position: absolute;
  top: 44px;
  left: 16px;
  background: rgba(13, 17, 23, 0.72);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  border: 1px solid var(--border);
  border-radius: 6px;
  min-width: 220px;
  max-height: 320px;
  overflow-y: auto;
  z-index: 20;
  box-shadow: 0 4px 24px rgba(0, 0, 0, 0.6);
}
#channel-dropdown.open { display: block; }
#channel-dropdown::-webkit-scrollbar { width: 3px; }
#channel-dropdown::-webkit-scrollbar-track { background: transparent; }
#channel-dropdown::-webkit-scrollbar-thumb {
  background: var(--border);
  border-radius: 2px;
}

.channel-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  transition: background 0.15s;
  cursor: pointer;
  font-size: 12px;
  color: var(--primary);
  opacity: 0.65;
}
.channel-row:last-child { border-bottom: none; }
.channel-row:hover { background: rgba(0, 212, 255, 0.03); opacity: 0.85; }
.channel-row.active {
  opacity: 1;
  font-weight: bold;
  background: rgba(0, 212, 255, 0.05);
}

.unread-badge {
  background: var(--primary);
  color: var(--bg);
  font-size: 9px;
  font-weight: bold;
  padding: 1px 6px;
  border-radius: 8px;
  min-width: 16px;
  text-align: center;
}

/* ================================================================ */
/* MESSAGES                                                         */
/* ================================================================ */

#messages {
  flex: 1;
  overflow-y: auto;
  padding: 8px 0;
  display: flex;
  flex-direction: column;
  gap: 0;
  font-family: var(--font-ui);
  font-size: var(--font-ui-size);
}

#messages::-webkit-scrollbar { width: var(--scrollbar-width); }
#messages::-webkit-scrollbar-track { background: transparent; }
#messages::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
#messages::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.18); }

.msg {
  display: flex;
  gap: 6px;
  font-family: var(--font-ui);
  font-size: var(--font-ui-size);
  line-height: 1.5;
  word-break: break-word;
  padding: 3px 12px;
  border-bottom: var(--border-width) solid var(--color-border);
  transition: background var(--transition-speed) ease;
}

.msg:hover {
  background: rgba(255,255,255,0.02);
}

.msg.own {
  background: rgba(0,212,255,0.03);
}

.msg-time {
  color: var(--color-text-muted);
  font-family: var(--font-ui);
  font-size: 10px;
  flex-shrink: 0;
  min-width: 38px;
  padding-top: 3px;
  opacity: 0.7;
}

.msg-nick {
  font-family: var(--font-ui);
  font-weight: 600;
  font-size: 12px;
  flex-shrink: 0;
  cursor: default;
}

.msg-text {
  color: var(--color-text);
  font-family: var(--font-ui);
}

.msg-image {
  max-width: 300px;
  max-height: 200px;
  border-radius: 4px;
  cursor: pointer;
  border: 1px solid var(--color-border);
  transition: border-color 0.15s ease, opacity 0.15s ease;
}
.msg-image:hover {
  border-color: var(--color-border-focused);
  opacity: 0.9;
}

#image-lightbox {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.85);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 200;
  cursor: pointer;
}
#image-lightbox.open { display: flex; }
#image-lightbox img {
  max-width: 90vw;
  max-height: 90vh;
  border-radius: 6px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
}

#paste-preview {
  display: none;
  align-items: center;
  gap: 8px;
  padding: 6px 12px;
  border-top: var(--border-width) solid var(--color-border);
  background: rgba(0, 212, 255, 0.03);
  flex-shrink: 0;
}
#paste-preview.show { display: flex; }
#paste-preview img {
  max-width: 60px;
  max-height: 40px;
  border-radius: 3px;
  border: 1px solid var(--color-border);
}
#paste-preview .paste-info {
  flex: 1;
  font-size: 10px;
  color: var(--color-text-muted);
}
#paste-cancel {
  background: none;
  border: 1px solid var(--color-border);
  color: var(--color-text-muted);
  font-family: var(--font-ui);
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 3px;
  cursor: pointer;
}
#paste-send {
  background: none;
  border: 1px solid var(--color-border-focused);
  color: var(--color-primary);
  font-family: var(--font-ui);
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 3px;
  cursor: pointer;
}

.msg-verify {
  flex-shrink: 0;
  font-size: 10px;
  min-width: 14px;
  text-align: center;
  padding-top: 2px;
  cursor: help;
}
.msg-verify.verified { color: var(--success); opacity: 0.7; }
.msg-verify.unverified { color: var(--color-text-muted); opacity: 0.5; }
.msg-verify.key-changed { color: var(--accent); opacity: 0.9; }
.msg-verify.invalid { color: var(--danger); opacity: 0.9; }

.dm-btn {
  background: rgba(0, 212, 255, 0.06);
  border: 1px solid var(--border);
  color: var(--primary);
  opacity: 0.45;
  font-family: 'Courier New', monospace;
  font-size: 9px;
  padding: 2px 8px;
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.15s;
  flex-shrink: 0;
  margin-left: auto;
}
.dm-btn:hover {
  opacity: 0.9;
  box-shadow: 0 0 6px rgba(0, 229, 255, 0.15);
}

#dm-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 16px;
  background: rgba(0, 212, 255, 0.04);
  border-bottom: 1px solid rgba(0, 212, 255, 0.2);
  font-size: 11px;
  color: var(--primary);
  flex-shrink: 0;
}
#dm-header.hidden { display: none; }
#dm-header-info { display: flex; align-items: center; gap: 8px; }
#dm-header-icon { font-size: 14px; }
.dm-fp {
  font-size: 9px;
  color: var(--color-text-muted);
  font-family: 'Courier New', monospace;
}
#dm-close-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--color-text-muted);
  font-family: 'Courier New', monospace;
  font-size: 10px;
  padding: 2px 10px;
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.15s;
}
#dm-close-btn:hover {
  color: var(--accent);
  border-color: var(--accent);
}
#messages.dm-active {
  background: rgba(0, 212, 255, 0.02);
}

.msg-system {
  color: var(--color-text-muted);
  font-family: var(--font-ui);
  font-size: 11px;
  font-style: italic;
  padding: 2px 12px;
  opacity: 0.8;
}

.msg-system.join { color: var(--color-success); opacity: 0.7; }
.msg-system.leave { color: var(--color-primary); opacity: 0.7; }
.msg-blocked {
  color: var(--color-error);
  font-family: var(--font-ui);
  font-size: 11px;
  font-style: italic;
  opacity: 0.5;
  padding: 2px 12px;
}

#empty-state {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  flex: 1;
  color: var(--color-text-muted);
  font-family: var(--font-ui);
  font-size: var(--font-ui-size);
  gap: 6px;
  padding: 40px;
  text-align: center;
  opacity: 0.6;
}

#empty-state .icon {
  font-size: 28px;
  opacity: 0.3;
}

/* ================================================================ */
/* INPUT BAR                                                        */
/* ================================================================ */

#input-bar {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 12px;
  border-top: var(--border-width) solid var(--color-border);
  flex-shrink: 0;
}

#msg-input {
  flex: 1;
  background: transparent;
  border: var(--border-width) solid var(--color-border);
  border-radius: var(--border-radius);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-ui-size);
  padding: 7px 12px;
  outline: none;
  transition: border-color var(--transition-speed) ease;
}

#msg-input:focus {
  border-color: var(--color-border-focused);
}

#msg-input::placeholder { color: var(--color-text-muted); opacity: 0.5; }

#send-btn {
  background: transparent;
  border: var(--border-width) solid var(--color-border);
  border-radius: var(--border-radius);
  color: var(--color-text-muted);
  font-family: var(--font-ui);
  font-size: 12px;
  font-weight: 500;
  padding: 7px 14px;
  cursor: pointer;
  transition: all var(--transition-speed) ease;
}

#send-btn:hover {
  color: var(--color-text);
  border-color: var(--color-border-focused);
}

#send-btn:active {
  background: rgba(255,255,255,0.03);
}

#send-btn:disabled {
  opacity: 0.25;
  cursor: not-allowed;
}

#char-count {
  color: var(--color-text-muted);
  font-family: var(--font-ui);
  font-size: 10px;
  align-self: center;
  min-width: 36px;
  text-align: right;
  opacity: 0.6;
}

#char-count.warn { color: var(--color-primary); opacity: 1; }
#char-count.over { color: var(--color-error); opacity: 1; }

/* ================================================================ */
/* NICKNAME OVERLAY                                                 */
/* ================================================================ */

#nick-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(4px);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

#nick-overlay.hidden { display: none; }
.hidden { display: none !important; }

#nick-panel {
  background: var(--color-panel-bg);
  border: var(--border-width) solid var(--color-border-focused);
  border-radius: var(--border-radius);
  padding: 28px 24px;
  width: 280px;
  text-align: center;
}

#nick-panel h2 {
  font-family: var(--font-ui);
  font-size: 14px;
  font-weight: 600;
  color: var(--color-text);
  margin-bottom: 4px;
}

#nick-panel p {
  font-family: var(--font-ui);
  font-size: 11px;
  color: var(--color-text-muted);
  margin-bottom: 18px;
}

#nick-input {
  width: 100%;
  background: transparent;
  border: var(--border-width) solid var(--color-border);
  border-radius: var(--border-radius);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-ui-size);
  padding: 8px 12px;
  outline: none;
  text-align: center;
  margin-bottom: 12px;
  transition: border-color var(--transition-speed) ease;
}

#nick-input:focus {
  border-color: var(--color-border-focused);
}

#nick-input::placeholder { color: var(--color-text-muted); opacity: 0.5; }

#nick-join-btn {
  width: 100%;
  background: transparent;
  border: var(--border-width) solid var(--color-border);
  border-radius: var(--border-radius);
  color: var(--color-text);
  font-family: var(--font-ui);
  font-size: var(--font-ui-size);
  font-weight: 500;
  padding: 8px;
  cursor: pointer;
  transition: all var(--transition-speed) ease;
}

#nick-join-btn:hover {
  border-color: var(--color-border-focused);
  background: rgba(255,255,255,0.03);
}

/* ================================================================ */
/* RATE LIMIT FEEDBACK                                              */
/* ================================================================ */

#rate-feedback {
  position: fixed;
  top: 42px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(255, 68, 68, 0.08);
  border: var(--border-width) solid rgba(255, 68, 68, 0.2);
  color: var(--color-text-muted);
  font-family: var(--font-ui);
  font-size: 11px;
  padding: 5px 14px;
  border-radius: var(--border-radius);
  z-index: 50;
  opacity: 0;
  transition: opacity var(--transition-speed) ease;
  pointer-events: none;
}

#rate-feedback.show { opacity: 1; }


</style>
</head>
<body>



<!-- ============================================================== -->
<!-- HEADER                                                         -->
<!-- ============================================================== -->

<div id="header">
  <h1 id="channel-title" title="Click to switch channels">
    <span id="channel-name"># general</span>
    <span class="channel-chevron">&#9662;</span>
  </h1>
  <div id="header-meta">
    <span id="my-nick" title="Click to change nickname"></span>
    <span><span id="status-dot"></span><span id="status-text">offline</span></span>
    <span id="user-count">0 online</span>
  </div>
  <button id="close-btn" title="Close panel" onclick="if(window.ipc&&window.ipc.postMessage)window.ipc.postMessage(JSON.stringify({kind:'panel_close',payload:{}}))">&times;</button>
</div>

<!-- ============================================================== -->
<!-- ONLINE USERS DROPDOWN                                          -->
<!-- ============================================================== -->

<div id="online-dropdown">
  <div class="dd-header">Online Users</div>
  <div id="online-user-list"></div>
</div>

<div id="dm-header" class="hidden">
  <div id="dm-header-info">
    <span id="dm-header-icon">&#128274;</span>
    <span>DM with <strong id="dm-header-nick"></strong></span>
    <span id="dm-header-fp" class="dm-fp"></span>
  </div>
  <button id="dm-close-btn" title="Close DM and return to group chat">&#10005; Close</button>
</div>

<!-- ============================================================== -->
<!-- CHANNEL DROPDOWN                                               -->
<!-- ============================================================== -->

<div id="channel-dropdown">
  <div class="dd-header">CHANNELS</div>
  <div id="channel-list"></div>
  <div class="dd-header" id="dm-section-header" style="display:none;">DIRECT MESSAGES</div>
  <div id="dm-list"></div>
</div>

<!-- ============================================================== -->
<!-- MESSAGES                                                       -->
<!-- ============================================================== -->

<div id="messages">
  <div id="empty-state">
    <div class="icon">&#9881;</div>
    <div>No messages yet.</div>
    <div>Say something to get started.</div>
  </div>
</div>

<!-- ============================================================== -->
<!-- INPUT BAR                                                      -->
<!-- ============================================================== -->

<div id="input-bar">
  <input id="msg-input" type="text" placeholder="Type a message..." maxlength="500" autocomplete="off" disabled>
  <span id="char-count">0/500</span>
  <button id="send-btn" disabled>Send</button>
</div>

<!-- ============================================================== -->
<!-- RATE LIMIT FEEDBACK                                            -->
<!-- ============================================================== -->

<!-- Image paste preview bar -->
<div id="paste-preview">
  <img id="paste-thumb" src="" alt="preview">
  <span class="paste-info" id="paste-info">Image ready to send</span>
  <button id="paste-cancel">Cancel</button>
  <button id="paste-send">Send</button>
</div>

<!-- Image lightbox overlay -->
<div id="image-lightbox">
  <img id="lightbox-img" src="" alt="Full size">
</div>

<div id="rate-feedback">Slow down! Rate limit reached.</div>
<button id="retry-btn" class="hidden" style="
  position: fixed; bottom: 60px; left: 50%; transform: translateX(-50%);
  background: transparent; border: 0.5px solid var(--color-border); border-radius: 6px;
  color: var(--color-text-muted); font-family: var(--font-ui); font-size: 12px; font-weight: 500;
  padding: 7px 20px; cursor: pointer; z-index: 50;
  transition: all 150ms ease;
">Retry</button>

<!-- ============================================================== -->
<!-- NICKNAME OVERLAY                                               -->
<!-- ============================================================== -->

<div id="nick-overlay">
  <div id="nick-panel">
    <h2>Enter Chat</h2>
    <p>Choose a nickname to join the room.</p>
    <input id="nick-input" type="text" placeholder="Agent-XXXX" maxlength="20" autocomplete="off">
    <button id="nick-join-btn">Join</button>
  </div>
</div>

<!-- ============================================================== -->
<!-- SUPABASE CDN                                                   -->
<!-- ============================================================== -->

<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.97.0/dist/umd/supabase.min.js"
        integrity="sha384-1+ItoWbWcmVSm+Y+dJaUt4SEWNA21/jxef+Z0TSHHVy/dEUxEUEnZ1bHn6GT5hj+"
        crossorigin="anonymous"></script>

<script>
'use strict';

// =================================================================
// CONFIG
// =================================================================

const CONFIG = {
  // Supabase — publishable anon key + URL.
  // These are PUBLISHABLE keys by design (like Stripe publishable keys).
  SUPABASE_URL: 'https://ojmqzagktzkualzgpcbq.supabase.co',
  // nosemgrep: generic.secrets.security.detected-jwt-token.detected-jwt-token
  SUPABASE_KEY: 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9qbXF6YWdrdHprdWFsemdwY2JxIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzE5ODY1ODIsImV4cCI6MjA4NzU2MjU4Mn0.WkDiksXkye-YyL1RSbAYv1iVW_Sv5zwST0RcloN_0jQ',

  ROOM: 'jarvis-livechat',
  CHANNELS: [
    { id: 'jarvis-livechat', name: 'general', type: 'channel' },
    { id: 'jarvis-livechat-discord', name: 'discord', type: 'channel' },
    { id: 'jarvis-livechat-showoff', name: 'showoff', type: 'channel' },
    { id: 'jarvis-livechat-help', name: 'help', type: 'channel' },
    { id: 'jarvis-livechat-random', name: 'random', type: 'channel' },
    { id: 'jarvis-livechat-games', name: 'games', type: 'channel' },
    { id: 'jarvis-livechat-memes', name: 'memes', type: 'channel' },
  ],
  DEFAULT_CHANNEL: 'jarvis-livechat',
  MAX_MSG_LEN: 500,
  MAX_IMAGE_LEN: 150000,    // max base64 data URL length (~100KB) — must stay under Supabase 250KB broadcast limit after encryption
  IMAGE_MAX_WIDTH: 300,     // compress images to this max width
  IMAGE_QUALITY: 0.5,       // JPEG compression quality
  RATE_LIMIT_COUNT: 5,      // max messages per window
  RATE_LIMIT_WINDOW: 10000, // window in ms (10 seconds)
  SPAM_REPEAT_LIMIT: 3,     // block after N identical consecutive messages
  SPAM_CHAR_RATIO: 0.8,     // block if >80% of message is same character
  MIN_MSG_LEN: 1,
  DM_CHANNEL_PREFIX: 'jarvis-dm-',
};

// =================================================================
// AUTOMOD
// =================================================================

class AutoMod {
  constructor() {
    this._banWords = new Set([
      // Default ban list — add/remove via addBanWord/removeBanWord
      'slur_placeholder',
    ]);

    // Pre-compiled regexes for ban words (rebuilt on add/remove)
    this._banRegexes = [];
    this._rebuildRegexes();

    // Rate limit tracking: userId -> [timestamps]
    this._rateBuckets = new Map();

    // Spam tracking: userId -> [recent messages]
    this._spamHistory = new Map();

    // Periodic cleanup of stale Map entries (every 60s)
    this._cleanupInterval = setInterval(() => this._cleanup(), 60000);
  }

  /** Add a word to the ban list (case-insensitive). */
  addBanWord(word) {
    if (typeof word === 'string' && word.length > 0) {
      this._banWords.add(word.toLowerCase().trim());
      this._rebuildRegexes();
    }
  }

  /** Remove a word from the ban list. */
  removeBanWord(word) {
    this._banWords.delete(String(word).toLowerCase().trim());
    this._rebuildRegexes();
  }

  /** Rebuild pre-compiled regexes from ban word set. */
  _rebuildRegexes() {
    this._banRegexes = [];
    for (const word of this._banWords) {
      this._banRegexes.push(
        new RegExp('\\b' + this._escapeRegex(word) + '\\b', 'i')
      );
    }
  }

  /**
   * Check message against ban list.
   * Returns { ok: true } or { ok: false, reason: string }.
   */
  checkKeywords(text) {
    const lower = text.toLowerCase();
    for (const re of this._banRegexes) {
      if (re.test(lower)) {
        return { ok: false, reason: 'blocked_keyword' };
      }
    }
    return { ok: true };
  }

  /**
   * Sliding window rate limiter.
   * Returns true if message is allowed, false if rate limited.
   */
  checkRateLimit(userId, now) {
    if (!now) now = Date.now();
    let bucket = this._rateBuckets.get(userId);
    if (!bucket) {
      bucket = [];
      this._rateBuckets.set(userId, bucket);
    }

    // Prune timestamps outside the window
    const cutoff = now - CONFIG.RATE_LIMIT_WINDOW;
    while (bucket.length > 0 && bucket[0] <= cutoff) {
      bucket.shift();
    }

    if (bucket.length >= CONFIG.RATE_LIMIT_COUNT) {
      return false; // rate limited
    }

    bucket.push(now);
    return true;
  }

  /**
   * Check for spam patterns:
   * 1. Repeated identical messages
   * 2. Single character repeated (e.g. "aaaaaaaaaa")
   * Returns { ok: true } or { ok: false, reason: string }.
   */
  checkSpam(text, userId) {
    // Check repeated character ratio
    if (text.length > 5) {
      const charCounts = {};
      for (const ch of text) {
        charCounts[ch] = (charCounts[ch] || 0) + 1;
      }
      const maxCount = Math.max(...Object.values(charCounts));
      if (maxCount / text.length >= CONFIG.SPAM_CHAR_RATIO) {
        return { ok: false, reason: 'spam_repeated_chars' };
      }
    }

    // Check repeated identical messages from same user
    let history = this._spamHistory.get(userId);
    if (!history) {
      history = [];
      this._spamHistory.set(userId, history);
    }

    const normalized = text.toLowerCase().trim();
    history.push(normalized);
    // Keep only last N messages
    if (history.length > CONFIG.SPAM_REPEAT_LIMIT + 1) {
      history.shift();
    }

    // Check if last N messages are identical
    if (history.length >= CONFIG.SPAM_REPEAT_LIMIT) {
      const last = history.slice(-CONFIG.SPAM_REPEAT_LIMIT);
      if (last.every(m => m === last[0])) {
        return { ok: false, reason: 'spam_repeated_message' };
      }
    }

    return { ok: true };
  }

  /**
   * Full filter pipeline. Returns { ok, reason }.
   */
  filter(text, userId) {
    if (typeof text !== 'string' || text.trim().length === 0) {
      return { ok: false, reason: 'empty' };
    }

    const kw = this.checkKeywords(text);
    if (!kw.ok) return kw;

    const sp = this.checkSpam(text, userId);
    if (!sp.ok) return sp;

    return { ok: true };
  }

  /** Remove stale entries from rate buckets and spam history. */
  _cleanup() {
    const now = Date.now();
    const cutoff = now - CONFIG.RATE_LIMIT_WINDOW * 6; // 60s of staleness

    for (const [userId, bucket] of this._rateBuckets) {
      // Remove if all timestamps are stale
      if (bucket.length === 0 || bucket[bucket.length - 1] < cutoff) {
        this._rateBuckets.delete(userId);
      }
    }

    // Cap spam history to 200 users max
    if (this._spamHistory.size > 200) {
      const excess = this._spamHistory.size - 200;
      const iter = this._spamHistory.keys();
      for (let i = 0; i < excess; i++) {
        this._spamHistory.delete(iter.next().value);
      }
    }
  }

  /** Stop cleanup interval. */
  destroy() {
    if (this._cleanupInterval) {
      clearInterval(this._cleanupInterval);
      this._cleanupInterval = null;
    }
  }

  _escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  }
}

// =================================================================
// CRYPTO — E2E ENCRYPTION (AES-GCM + PBKDF2)
// =================================================================

const Crypto = {
  _defaultKeyHandle: null,

  /** Derive AES-GCM-256 key from room name via PBKDF2 (Rust-side). */
  async deriveKey(roomName) {
    var resp = await window.jarvis.ipc.request('crypto', {
      op: 'derive_room_key', params: { room: roomName }
    });
    this._defaultKeyHandle = resp.keyHandle;
  },

  /** Encrypt plaintext. Returns { iv, ct } as base64 strings. Optional keyHandle overrides default. */
  async encrypt(plaintext, keyHandle) {
    var kh = keyHandle || this._defaultKeyHandle;
    if (kh == null) throw new Error('Key not derived');
    return await window.jarvis.ipc.request('crypto', {
      op: 'encrypt', params: { plaintext: plaintext, keyHandle: kh }
    });
  },

  /** Decrypt { iv, ct } payload. Returns plaintext string. Optional keyHandle overrides default. */
  async decrypt(ivB64, ctB64, keyHandle) {
    var kh = keyHandle || this._defaultKeyHandle;
    if (kh == null) throw new Error('Key not derived');
    var resp = await window.jarvis.ipc.request('crypto', {
      op: 'decrypt', params: { iv: ivB64, ct: ctB64, keyHandle: kh }
    });
    return resp.plaintext;
  },
};

// =================================================================
// CRYPTOGRAPHIC IDENTITY (ECDSA P-256)
// =================================================================

const Identity = {
  fingerprint: null,
  pubkeyBase64: null,
  dhPubkeyBase64: null,

  /** Load identity from Rust CryptoService (keys managed Rust-side). */
  async init() {
    var resp = await window.jarvis.ipc.request('crypto', {
      op: 'init', params: {}
    });
    this.fingerprint = resp.fingerprint;
    this.pubkeyBase64 = resp.pubkey;
    this.dhPubkeyBase64 = resp.dhPubkey;
  },

  /** Sign data with ECDSA-P256-SHA256 (Rust-side). Returns base64 signature. */
  async sign(dataString) {
    var resp = await window.jarvis.ipc.request('crypto', {
      op: 'sign', params: { data: dataString }
    });
    return resp.signature;
  },

  /** Verify ECDSA-P256-SHA256 signature (Rust-side). Returns boolean. */
  async verify(dataString, signatureBase64, pubkeyBase64) {
    var resp = await window.jarvis.ipc.request('crypto', {
      op: 'verify', params: {
        data: dataString,
        signature: signatureBase64,
        pubkey: pubkeyBase64
      }
    });
    return resp.valid;
  },

  /** Derive shared AES-256 key via ECDH (Rust-side). Returns opaque key handle. */
  async deriveSharedKey(otherDhPubkeyBase64) {
    var resp = await window.jarvis.ipc.request('crypto', {
      op: 'derive_shared_key', params: { dhPubkey: otherDhPubkeyBase64 }
    });
    return resp.keyHandle;
  },
};

// =================================================================
// TOFU TRUST STORE
// =================================================================

const TrustStore = {
  _KEY: 'jarvis-chat-tofu',
  _store: {},

  init() {
    try {
      this._store = JSON.parse(localStorage.getItem(this._KEY) || '{}');
    } catch (_) {
      this._store = {};
    }
  },

  check(nick, fingerprint) {
    var entry = this._store[nick];
    if (!entry) {
      this._store[nick] = { fingerprint: fingerprint, firstSeen: Date.now(), lastSeen: Date.now() };
      this._save();
      return 'new';
    }
    if (entry.fingerprint === fingerprint) {
      entry.lastSeen = Date.now();
      this._save();
      return 'trusted';
    }
    return 'changed';
  },

  getFingerprint(nick) {
    var entry = this._store[nick];
    return entry ? entry.fingerprint : null;
  },

  _save() {
    try {
      localStorage.setItem(this._KEY, JSON.stringify(this._store));
    } catch (_) {}
  },
};

// =================================================================
// UI HELPERS
// =================================================================

const $ = (sel) => document.querySelector(sel);

const UI = {
  messagesEl: null,
  emptyState: null,
  msgInput: null,
  sendBtn: null,
  charCount: null,
  statusDot: null,
  statusText: null,
  userCount: null,
  rateFeedback: null,
  nickOverlay: null,
  nickInput: null,
  myNick: null,
  retryBtn: null,
  _rateFeedbackTimeout: null,
  _retryCallback: null,

  init() {
    this.messagesEl = $('#messages');
    this.emptyState = $('#empty-state');
    this.msgInput = $('#msg-input');
    this.sendBtn = $('#send-btn');
    this.charCount = $('#char-count');
    this.statusDot = $('#status-dot');
    this.statusText = $('#status-text');
    this.userCount = $('#user-count');
    this.rateFeedback = $('#rate-feedback');
    this.nickOverlay = $('#nick-overlay');
    this.nickInput = $('#nick-input');
    this.myNick = $('#my-nick');
    this.retryBtn = $('#retry-btn');

    this.retryBtn.addEventListener('click', () => {
      if (this._retryCallback) this._retryCallback();
    });
  },

  setStatus(state) {
    this.statusDot.className = state; // 'connected', 'connecting', or ''
    this.statusText.textContent = state || 'offline';
  },

  setUserCount(n) {
    this.userCount.textContent = n + ' online';
  },

  enableInput() {
    this.msgInput.disabled = false;
    this.sendBtn.disabled = false;
    this.msgInput.focus();
  },

  disableInput() {
    this.msgInput.disabled = true;
    this.sendBtn.disabled = true;
  },

  hideNickOverlay() {
    this.nickOverlay.classList.add('hidden');
  },

  showNickOverlay() {
    this.nickOverlay.classList.remove('hidden');
    this.nickInput.focus();
    this.nickInput.select();
  },

  setMyNick(nick) {
    this.myNick.textContent = nick;
  },

  addMessage(nick, text, time, nickColor, verifyStatus) {
    this._hideEmpty();
    const row = document.createElement('div');
    row.className = 'msg';

    const timeEl = document.createElement('span');
    timeEl.className = 'msg-time';
    timeEl.textContent = time;

    const verifyEl = document.createElement('span');
    verifyEl.className = 'msg-verify';
    if (verifyStatus === 'verified' || verifyStatus === 'self') {
      verifyEl.classList.add('verified');
      verifyEl.textContent = '\u2713';
      verifyEl.title = verifyStatus === 'self' ? 'Your message' : 'Verified identity';
    } else if (verifyStatus === 'key-changed') {
      verifyEl.classList.add('key-changed');
      verifyEl.textContent = '\u26A0';
      verifyEl.title = 'Identity key changed! Possible impersonation.';
    } else if (verifyStatus === 'invalid') {
      verifyEl.classList.add('invalid');
      verifyEl.textContent = '\u2717';
      verifyEl.title = 'Signature verification failed';
    } else {
      verifyEl.classList.add('unverified');
      verifyEl.textContent = '?';
      verifyEl.title = 'Unverified (no signature)';
    }

    const nickEl = document.createElement('span');
    nickEl.className = 'msg-nick';
    nickEl.textContent = nick + ':';
    nickEl.style.color = nickColor || var_primary();

    const textEl = document.createElement('span');
    textEl.className = 'msg-text';
    textEl.textContent = text; // textContent = XSS safe

    row.appendChild(timeEl);
    row.appendChild(verifyEl);
    row.appendChild(nickEl);
    row.appendChild(textEl);
    this.messagesEl.appendChild(row);
    this._scrollToBottom();
  },

  addImage(nick, dataUrl, time, nickColor, verifyStatus) {
    this._hideEmpty();
    const row = document.createElement('div');
    row.className = 'msg';

    const timeEl = document.createElement('span');
    timeEl.className = 'msg-time';
    timeEl.textContent = time;

    const verifyEl = document.createElement('span');
    verifyEl.className = 'msg-verify';
    if (verifyStatus === 'verified' || verifyStatus === 'self') {
      verifyEl.classList.add('verified');
      verifyEl.textContent = '\u2713';
    } else if (verifyStatus === 'key-changed') {
      verifyEl.classList.add('key-changed');
      verifyEl.textContent = '\u26A0';
    } else if (verifyStatus === 'invalid') {
      verifyEl.classList.add('invalid');
      verifyEl.textContent = '\u2717';
    } else {
      verifyEl.classList.add('unverified');
      verifyEl.textContent = '?';
    }

    const nickEl = document.createElement('span');
    nickEl.className = 'msg-nick';
    nickEl.textContent = nick + ':';
    nickEl.style.color = nickColor || var_primary();

    const imgEl = document.createElement('img');
    imgEl.className = 'msg-image';
    imgEl.src = dataUrl;
    imgEl.alt = 'Image from ' + nick;
    imgEl.addEventListener('click', function() {
      var lb = document.getElementById('image-lightbox');
      document.getElementById('lightbox-img').src = dataUrl;
      lb.classList.add('open');
    });

    row.appendChild(timeEl);
    row.appendChild(verifyEl);
    row.appendChild(nickEl);
    row.appendChild(imgEl);
    this.messagesEl.appendChild(row);
    this._scrollToBottom();
  },

  addSystemMessage(text, type) {
    this._hideEmpty();
    const row = document.createElement('div');
    row.className = 'msg-system' + (type ? ' ' + type : '');
    row.textContent = text; // textContent = XSS safe
    this.messagesEl.appendChild(row);
    this._scrollToBottom();
  },

  addBlockedNotice(reason) {
    const row = document.createElement('div');
    row.className = 'msg-blocked';
    row.textContent = '[message filtered: ' + reason + ']';
    this.messagesEl.appendChild(row);
    this._scrollToBottom();
  },

  showRetryButton(callback) {
    this._retryCallback = callback;
    this.retryBtn.classList.remove('hidden');
  },

  hideRetryButton() {
    this.retryBtn.classList.add('hidden');
    this._retryCallback = null;
  },

  showRateLimitFeedback() {
    this.rateFeedback.classList.add('show');
    clearTimeout(this._rateFeedbackTimeout);
    this._rateFeedbackTimeout = setTimeout(() => {
      this.rateFeedback.classList.remove('show');
    }, 2000);
  },

  updateChannelName(name) {
    $('#channel-name').textContent = name;
  },

  clearMessages() {
    while (this.messagesEl.firstChild) {
      this.messagesEl.removeChild(this.messagesEl.firstChild);
    }
    this.emptyState = null;
  },

  showEmptyState() {
    if (this.emptyState) return;
    var empty = document.createElement('div');
    empty.id = 'empty-state';
    var icon = document.createElement('div');
    icon.className = 'icon';
    icon.innerHTML = '&#9881;';
    var line1 = document.createElement('div');
    line1.textContent = 'No messages yet.';
    var line2 = document.createElement('div');
    line2.textContent = 'Say something to get started.';
    empty.appendChild(icon);
    empty.appendChild(line1);
    empty.appendChild(line2);
    this.messagesEl.appendChild(empty);
    this.emptyState = empty;
  },

  updateCharCount(len) {
    this.charCount.textContent = len + '/' + CONFIG.MAX_MSG_LEN;
    this.charCount.className = '';
    if (len > CONFIG.MAX_MSG_LEN * 0.9) this.charCount.className = 'warn';
    if (len >= CONFIG.MAX_MSG_LEN) this.charCount.className = 'over';
  },

  _hideEmpty() {
    if (this.emptyState) {
      this.emptyState.remove();
      this.emptyState = null;
    }
  },

  _scrollToBottom() {
    // Cap DOM nodes to prevent unbounded growth
    const MAX_MESSAGES = 500;
    while (this.messagesEl.children.length > MAX_MESSAGES) {
      this.messagesEl.removeChild(this.messagesEl.firstChild);
    }
    this.messagesEl.scrollTop = this.messagesEl.scrollHeight;
  },
};

function var_primary() { return '#00e5ff'; }

/** Generate a deterministic color from a string (for nick colors). */
function nickColor(nick) {
  let hash = 0;
  for (let i = 0; i < nick.length; i++) {
    hash = nick.charCodeAt(i) + ((hash << 5) - hash);
  }
  const colors = [
    '#00e5ff', '#ff6b00', '#00ff88', '#ff44aa',
    '#44aaff', '#ffdd00', '#aa66ff', '#66ffcc',
  ];
  return colors[Math.abs(hash) % colors.length];
}

/** Format timestamp to HH:MM. */
function formatTime(ts) {
  const d = new Date(ts);
  return d.getHours().toString().padStart(2, '0') + ':' +
         d.getMinutes().toString().padStart(2, '0');
}

// =================================================================
// EMOJI SHORTCODES
// =================================================================

const EMOJI_MAP = {
  ':smile:':'\u{1F604}',':grin:':'\u{1F601}',':laugh:':'\u{1F602}',':joy:':'\u{1F602}',
  ':wink:':'\u{1F609}',':blush:':'\u{1F60A}',':heart_eyes:':'\u{1F60D}',':kiss:':'\u{1F618}',
  ':thinking:':'\u{1F914}',':neutral:':'\u{1F610}',':expressionless:':'\u{1F611}',
  ':unamused:':'\u{1F612}',':sweat:':'\u{1F613}',':pensive:':'\u{1F614}',
  ':confused:':'\u{1F615}',':disappointed:':'\u{1F61E}',':worried:':'\u{1F61F}',
  ':angry:':'\u{1F620}',':rage:':'\u{1F621}',':cry:':'\u{1F622}',':sob:':'\u{1F62D}',
  ':scream:':'\u{1F631}',':cool:':'\u{1F60E}',':nerd:':'\u{1F913}',':clown:':'\u{1F921}',
  ':skull:':'\u{1F480}',':ghost:':'\u{1F47B}',':alien:':'\u{1F47D}',':robot:':'\u{1F916}',
  ':wave:':'\u{1F44B}',':ok:':'\u{1F44C}',':thumbsup:':'\u{1F44D}',':thumbsdown:':'\u{1F44E}',
  ':clap:':'\u{1F44F}',':pray:':'\u{1F64F}',':muscle:':'\u{1F4AA}',':fire:':'\u{1F525}',
  ':heart:':'\u{2764}\u{FE0F}',':broken_heart:':'\u{1F494}',':star:':'\u{2B50}',
  ':sparkles:':'\u{2728}',':100:':'\u{1F4AF}',':check:':'\u{2705}',':x:':'\u{274C}',
  ':warning:':'\u{26A0}\u{FE0F}',':question:':'\u{2753}',':exclamation:':'\u{2757}',
  ':rocket:':'\u{1F680}',':eyes:':'\u{1F440}',':brain:':'\u{1F9E0}',':bug:':'\u{1F41B}',
  ':gear:':'\u{2699}\u{FE0F}',':lock:':'\u{1F512}',':key:':'\u{1F511}',':bulb:':'\u{1F4A1}',
  ':zap:':'\u{26A1}',':boom:':'\u{1F4A5}',':party:':'\u{1F389}',':trophy:':'\u{1F3C6}',
};

/** Replace :shortcode: with emoji in text. */
function replaceEmoji(text) {
  return text.replace(/:[a-z_]+:/g, function(match) {
    return EMOJI_MAP[match] || match;
  });
}

/** Check if a string is an image data URL. */
function isImageDataUrl(text) {
  return typeof text === 'string' && text.startsWith('data:image/');
}

/** Compress an image blob to JPEG data URL via canvas. */
function compressImage(blob) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      var w = img.width;
      var h = img.height;
      if (w > CONFIG.IMAGE_MAX_WIDTH) {
        h = Math.round(h * (CONFIG.IMAGE_MAX_WIDTH / w));
        w = CONFIG.IMAGE_MAX_WIDTH;
      }
      var canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      var ctx = canvas.getContext('2d');
      ctx.drawImage(img, 0, 0, w, h);
      var dataUrl = canvas.toDataURL('image/jpeg', CONFIG.IMAGE_QUALITY);
      URL.revokeObjectURL(img.src);
      resolve(dataUrl);
    };
    img.onerror = function() {
      URL.revokeObjectURL(img.src);
      reject(new Error('Failed to load image'));
    };
    img.src = URL.createObjectURL(blob);
  });
}

/** Check if text looks like a local image file path. */
function isImagePath(text) {
  var trimmed = text.trim();
  if (trimmed.length < 4) return false;
  if (!/^(\/|~\/|\.\/|\.\.\/)/.test(trimmed)) return false;
  return /\.(png|jpg|jpeg|gif|webp|bmp|svg|tiff?)$/i.test(trimmed);
}

// =================================================================
// CHAT APP
// =================================================================

const Chat = {
  userId: null,
  nick: null,
  client: null,
  automod: null,
  _senderRateBucket: [],
  _activeChannelId: null,
  _channels: new Map(),
  _dmList: [],
  _unreadCounts: new Map(),
  _keyCache: new Map(),
  _dmMode: false,
  _dmKey: null,
  _dmTargetNick: null,
  _dmTargetFp: null,
  _switching: false,

  /** Get the primary (general) channel subscription. */
  get _primaryChannel() {
    var data = this._channels.get(CONFIG.DEFAULT_CHANNEL);
    return data ? data.sub : null;
  },

  /** Get display name for a channel ID. */
  _getChannelDisplayName(channelId) {
    var ch = CONFIG.CHANNELS.find(function(c) { return c.id === channelId; });
    if (ch) return '# ' + ch.name;
    var dm = this._dmList.find(function(d) { return d.channelId === channelId; });
    if (dm) return '@ ' + dm.nick;
    return channelId;
  },

  async start(nickname) {
    // Guard: Supabase CDN must have loaded
    if (typeof supabase === 'undefined' || !supabase.createClient) {
      UI.addSystemMessage(
        'Error: Supabase library failed to load. Check your connection.',
        'leave'
      );
      return;
    }

    this.userId = crypto.randomUUID();
    this.nick = nickname.trim().slice(0, 20);
    if (!this.automod) this.automod = new AutoMod();
    this._signingDisabled = false;

    // Initialize cryptographic identity
    try {
      await Identity.init();
      TrustStore.init();
      TrustStore.check(this.nick, Identity.fingerprint);
    } catch (err) {
      this._signingDisabled = true;
      console.warn('Identity init failed, messages will be unsigned:', err);
    }

    // Moderate nickname before joining
    const nickCheck = this.automod.checkKeywords(this.nick);
    if (!nickCheck.ok) {
      UI.addSystemMessage('That nickname is not allowed. Try another.', 'leave');
      UI.showNickOverlay();
      return;
    }

    UI.setMyNick(this.nick);

    // Save nick to localStorage for persistence
    try { localStorage.setItem('jarvis-chat-nick', this.nick); } catch (_) {}

    // Initialize Supabase client
    const { createClient } = supabase;
    this.client = createClient(CONFIG.SUPABASE_URL, CONFIG.SUPABASE_KEY, {
      realtime: { params: { eventsPerSecond: 10 } },
    });

    UI.setStatus('connecting');
    UI.hideNickOverlay();

    // Initialize per-channel message stores
    this._channels = new Map();
    this._unreadCounts = new Map();
    this._keyCache = new Map();
    this._dmList = [];

    for (var i = 0; i < CONFIG.CHANNELS.length; i++) {
      var ch = CONFIG.CHANNELS[i];
      this._channels.set(ch.id, { sub: null, messages: [] });
      this._unreadCounts.set(ch.id, 0);
    }

    // Subscribe to ALL channels at startup (general carries presence)
    this._activeChannelId = CONFIG.DEFAULT_CHANNEL;
    this._reconnectAttempts = 0;
    for (var i = 0; i < CONFIG.CHANNELS.length; i++) {
      var ch = CONFIG.CHANNELS[i];
      var isPrimary = (ch.id === CONFIG.DEFAULT_CHANNEL);
      await this._subscribeChannel(ch.id, isPrimary);
    }

    UI.updateChannelName(this._getChannelDisplayName(this._activeChannelId));
  },

  /** Subscribe to a Supabase channel. isPrimary=true for the general channel (carries presence). */
  async _subscribeChannel(channelId, isPrimary) {
    // Derive E2E key for this channel
    await Crypto.deriveKey(channelId);
    // Cache the key for background decryption
    this._keyCache.set(channelId, Crypto._defaultKeyHandle);

    var channelConfig = {
      config: {
        broadcast: { self: false, ack: true },
      },
    };

    if (isPrimary) {
      channelConfig.config.presence = { key: this.userId };
    }

    var sub = this.client.channel(channelId, channelConfig);
    var self = this;

    // Broadcast listener
    sub.on('broadcast', { event: 'message' }, function(payload) {
      console.log('[chat-debug] broadcast received on', channelId, 'payload keys:', payload ? Object.keys(payload) : 'null');
      self._onChannelMessage(channelId, payload.payload);
    });

    // Presence listeners (only on primary)
    if (isPrimary) {
      sub.on('presence', { event: 'sync' }, function() {
        var state = sub.presenceState();
        UI.setUserCount(Object.keys(state).length);
      });
      sub.on('presence', { event: 'join' }, function(data) {
        if (data.key !== self.userId && data.newPresences.length > 0) {
          var joiner = data.newPresences[0].nick || 'Unknown';
          self._addSystemToChannel(self._activeChannelId, joiner + ' joined', 'join');
        }
      });
      sub.on('presence', { event: 'leave' }, function(data) {
        if (data.leftPresences.length > 0) {
          var leaver = data.leftPresences[0].nick || 'Unknown';
          self._addSystemToChannel(self._activeChannelId, leaver + ' left', 'leave');
        }
      });
    }

    // Store the subscription reference
    var channelData = this._channels.get(channelId);
    if (channelData) {
      channelData.sub = sub;
    } else {
      this._channels.set(channelId, { sub: sub, messages: [] });
    }

    // Connection timeout
    var connected = false;
    var connectTimeout = setTimeout(function() {
      if (!connected) {
        UI.setStatus('');
        self._addSystemToChannel(channelId, 'Connection timed out. Click RETRY to try again.', 'leave');
        UI.showRetryButton(function() {
          UI.hideRetryButton();
          self.client.removeChannel(sub);
          self.client = null;
          Chat.start(self.nick);
        });
      }
    }, 10000);

    sub.subscribe(async function(status) {
      console.log('[chat-debug] channel', channelId, 'subscribe status:', status);
      if (status === 'SUBSCRIBED') {
        connected = true;
        clearTimeout(connectTimeout);
        UI.setStatus('connected');
        UI.enableInput();
        self._reconnectAttempts = 0;
        if (isPrimary) {
          await sub.track({
            nick: self.nick,
            online_at: new Date().toISOString(),
            pubkey: Identity.pubkeyBase64 || null,
            fingerprint: Identity.fingerprint || null,
            dhPubkey: Identity.dhPubkeyBase64 || null,
          });
        }
        self._addSystemToChannel(channelId, 'Connected as ' + self.nick, 'join');
      } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
        if (isPrimary) {
          UI.setStatus('');
          UI.disableInput();
          self._addSystemToChannel(channelId, 'Disconnected from server.', 'leave');
          self._scheduleReconnect();
        }
      }
    });
  },

  /** Derive and cache an E2E key for a channel (for background decryption). */
  async _deriveKeyForChannel(channelId) {
    if (this._keyCache.has(channelId)) return this._keyCache.get(channelId);
    var resp = await window.jarvis.ipc.request('crypto', {
      op: 'derive_room_key', params: { room: channelId }
    });
    this._keyCache.set(channelId, resp.keyHandle);
    return resp.keyHandle;
  },

  /** Store a system message in a channel's history and render if active. */
  _addSystemToChannel(channelId, text, systemType) {
    var channelData = this._channels.get(channelId);
    if (channelData) {
      channelData.messages.push({ type: 'system', text: text, systemType: systemType });
      if (channelData.messages.length > 500) channelData.messages.shift();
    }
    if (channelId === this._activeChannelId) {
      UI.addSystemMessage(text, systemType);
    }
  },

  /** Unified message handler for all channels. */
  async _onChannelMessage(channelId, payload) {
    console.log('[chat-debug] _onChannelMessage called, channel:', channelId, 'has payload:', !!payload, 'has iv:', !!(payload && payload.iv), 'has ct:', !!(payload && payload.ct));
    if (!payload || !payload.iv || !payload.ct) { console.warn('[chat-debug] DROP: missing payload/iv/ct'); return; }
    if (payload.userId === this.userId) { console.log('[chat-debug] DROP: self-message'); return; }

    // Decrypt with the correct key for this channel
    var plaintext;
    try {
      if (channelId === this._activeChannelId && !this._dmMode) {
        plaintext = await Crypto.decrypt(payload.iv, payload.ct);
      } else {
        var key = await this._deriveKeyForChannel(channelId);
        plaintext = await Crypto.decrypt(payload.iv, payload.ct, key);
      }
      console.log('[chat-debug] decrypt OK, plaintext length:', plaintext.length);
    } catch (err) {
      console.error('[chat-debug] DROP: decrypt failed:', err.message || err);
      return;
    }

    // Detect image messages (skip text automod for images)
    var isImage = isImageDataUrl(plaintext);

    // Automod (text messages only)
    if (!isImage) {
      var filterResult = this.automod.filter(plaintext, payload.userId);
      if (!filterResult.ok) return;
    }
    if (!this.automod.checkRateLimit(payload.userId, Date.now())) return;

    var nick = (typeof payload.nick === 'string')
      ? payload.nick.trim().slice(0, 20) : 'Unknown';
    var nickCheck = this.automod.checkKeywords(nick);
    if (!nickCheck.ok) nick = 'Censored';

    // Verify signature
    var verifyStatus = 'unverified';
    if (payload.sig && payload.pubkey && payload.fingerprint) {
      var canonical = [payload.id, payload.userId, payload.nick, payload.ts, payload.iv, payload.ct].join('|');
      try {
        var valid = await Identity.verify(canonical, payload.sig, payload.pubkey);
        if (valid) {
          var tofuResult = TrustStore.check(nick, payload.fingerprint);
          if (tofuResult === 'trusted' || tofuResult === 'new') {
            verifyStatus = 'verified';
          } else if (tofuResult === 'changed') {
            verifyStatus = 'key-changed';
            this._addSystemToChannel(channelId,
              '\u26A0 WARNING: ' + nick + '\'s identity key has changed!', 'leave');
          }
        } else {
          verifyStatus = 'invalid';
        }
      } catch (err) {
        verifyStatus = 'invalid';
      }
    }

    var time = formatTime(payload.ts || Date.now());
    var msgType = isImage ? 'image' : 'msg';
    var msgObj = { nick: nick, text: plaintext, time: time, color: nickColor(nick), verifyStatus: verifyStatus, type: msgType };

    // Store in channel's message array
    var channelData = this._channels.get(channelId);
    if (channelData) {
      channelData.messages.push(msgObj);
      if (channelData.messages.length > 500) channelData.messages.shift();
    }

    // Render or increment unread
    if (channelId === this._activeChannelId) {
      if (isImage) {
        UI.addImage(nick, plaintext, time, nickColor(nick), verifyStatus);
      } else {
        UI.addMessage(nick, plaintext, time, nickColor(nick), verifyStatus);
      }
    } else {
      var current = this._unreadCounts.get(channelId) || 0;
      this._unreadCounts.set(channelId, current + 1);
    }
  },

  /** Switch to a different channel (instant — all channels pre-subscribed). */
  switchChannel(channelId) {
    if (channelId === this._activeChannelId) return;
    if (this._switching) return;
    this._switching = true;

    try {
      // Close DM mode if active
      if (this._dmMode) {
        this._closeDMChannel();
      }

      // Switch active channel
      this._activeChannelId = channelId;

      // Set the crypto default key from cache
      var cachedKey = this._keyCache.get(channelId);
      if (cachedKey != null) {
        Crypto._defaultKeyHandle = cachedKey;
      }

      // Clear unread
      this._unreadCounts.set(channelId, 0);

      // Re-render messages from the new channel's history
      UI.clearMessages();
      var channelData = this._channels.get(channelId);
      var messages = channelData ? channelData.messages : [];
      if (messages.length === 0) {
        UI.showEmptyState();
      } else {
        for (var i = 0; i < messages.length; i++) {
          var m = messages[i];
          if (m.type === 'system') {
            UI.addSystemMessage(m.text, m.systemType);
          } else if (m.type === 'image') {
            UI.addImage(m.nick, m.text, m.time, m.color, m.verifyStatus);
          } else {
            UI.addMessage(m.nick, m.text, m.time, m.color, m.verifyStatus);
          }
        }
      }

      // Update header
      UI.updateChannelName(this._getChannelDisplayName(channelId));
      var chName = this._getChannelDisplayName(channelId);
      UI.msgInput.placeholder = 'Message ' + chName + '...';
      UI.msgInput.focus();
    } finally {
      this._switching = false;
    }
  },

  /** Reconnect with exponential backoff (handles 24h Supabase limit). */
  _scheduleReconnect() {
    var MAX_ATTEMPTS = 8;
    if (this._reconnectAttempts >= MAX_ATTEMPTS) {
      UI.addSystemMessage('Max reconnect attempts reached. Reload the page.', 'leave');
      return;
    }
    this._reconnectAttempts++;
    var baseDelay = 2000;
    var maxDelay = 30000;
    var delay = Math.min(baseDelay * Math.pow(2, this._reconnectAttempts - 1), maxDelay);
    var jitter = delay * (0.75 + Math.random() * 0.5);
    var self = this;

    UI.addSystemMessage(
      'Reconnecting in ' + Math.round(jitter / 1000) + 's (attempt ' +
      this._reconnectAttempts + '/' + MAX_ATTEMPTS + ')...'
    );

    this._reconnectTimeout = setTimeout(async function() {
      UI.setStatus('connecting');
      try {
        // Remove old primary channel
        var primaryData = self._channels.get(CONFIG.DEFAULT_CHANNEL);
        if (primaryData && primaryData.sub) {
          self.client.removeChannel(primaryData.sub);
          primaryData.sub = null;
        }
        // Reconnect primary
        await self._subscribeChannel(CONFIG.DEFAULT_CHANNEL, true);
        // If viewing a different channel, reconnect that too
        if (self._activeChannelId !== CONFIG.DEFAULT_CHANNEL) {
          var activeData = self._channels.get(self._activeChannelId);
          if (activeData && activeData.sub) {
            self.client.removeChannel(activeData.sub);
            activeData.sub = null;
          }
          await self._subscribeChannel(self._activeChannelId, false);
        }
      } catch (err) {
        UI.addSystemMessage('Reconnect failed.', 'leave');
        self._scheduleReconnect();
      }
    }, jitter);
  },

  async send(text) {
    if (this._dmMode) return this.sendDM(text);
    text = text.trim();
    if (text.length === 0) return;

    var isImage = isImageDataUrl(text);
    var maxLen = isImage ? CONFIG.MAX_IMAGE_LEN : CONFIG.MAX_MSG_LEN;
    if (text.length > maxLen) {
      if (isImage) {
        UI.addSystemMessage('Image too large to send.', 'leave');
      }
      return;
    }

    // Apply emoji shortcode replacement for text messages
    if (!isImage) {
      text = replaceEmoji(text);
    }

    // Sender-side rate limit
    if (!this._checkSenderRateLimit()) {
      UI.showRateLimitFeedback();
      return;
    }

    // Sender-side automod (text only)
    if (!isImage) {
      var filterResult = this.automod.filter(text, this.userId);
      if (!filterResult.ok) {
        UI.addBlockedNotice('Your message was blocked: ' + filterResult.reason);
        return;
      }
    }

    // Encrypt the message
    var encrypted;
    try {
      encrypted = await Crypto.encrypt(text);
    } catch (err) {
      UI.addSystemMessage('Encryption error. Message not sent.');
      return;
    }

    var ts = Date.now();
    var msgId = crypto.randomUUID();

    // Sign the message
    var sig = null;
    if (!this._signingDisabled) {
      try {
        var canonical = [msgId, this.userId, this.nick, ts, encrypted.iv, encrypted.ct].join('|');
        sig = await Identity.sign(canonical);
      } catch (err) {
        console.warn('Signing failed:', err);
      }
    }

    var payload = {
      id: msgId,
      userId: this.userId,
      nick: this.nick,
      ts: ts,
      iv: encrypted.iv,
      ct: encrypted.ct,
      sig: sig,
      pubkey: Identity.pubkeyBase64 || null,
      fingerprint: Identity.fingerprint || null,
    };

    // Check broadcast payload size (Supabase Realtime limit ~250KB)
    var payloadSize = JSON.stringify(payload).length;
    console.log('[chat-debug] broadcast payload size:', payloadSize, 'bytes, ct length:', encrypted.ct.length);
    if (payloadSize > 240000) {
      UI.addSystemMessage('Message too large for broadcast (' + Math.round(payloadSize / 1024) + 'KB). Try a smaller image.', 'leave');
      return;
    }

    // Send via the active channel's subscription
    var activeSub = this._channels.get(this._activeChannelId);
    if (!activeSub || !activeSub.sub) {
      UI.addSystemMessage('Not connected to channel.', 'leave');
      return;
    }

    console.log('[chat-debug] sending broadcast on', this._activeChannelId, 'payload size:', payloadSize);
    try {
      var sendResult = await activeSub.sub.send({
        type: 'broadcast',
        event: 'message',
        payload: payload,
      });
      console.log('[chat-debug] send result:', sendResult);
    } catch (sendErr) {
      console.error('[chat-debug] send FAILED:', sendErr.message || sendErr);
      UI.addSystemMessage('Send failed: ' + (sendErr.message || 'unknown error'), 'leave');
      return;
    }

    // Store in local history
    var msgType = isImage ? 'image' : 'msg';
    var msgObj = { nick: this.nick, text: text, time: formatTime(ts), color: nickColor(this.nick), verifyStatus: 'self', type: msgType };
    activeSub.messages.push(msgObj);
    if (activeSub.messages.length > 500) activeSub.messages.shift();

    // Render locally
    if (isImage) {
      UI.addImage(this.nick, text, formatTime(ts), nickColor(this.nick), 'self');
    } else {
      UI.addMessage(this.nick, text, formatTime(ts), nickColor(this.nick), 'self');
    }
    UI.msgInput.value = '';
    UI.updateCharCount(0);
  },

  /** Sender-side rate limit (local only). */
  _checkSenderRateLimit() {
    var now = Date.now();
    var cutoff = now - CONFIG.RATE_LIMIT_WINDOW;
    this._senderRateBucket = this._senderRateBucket.filter(function(t) { return t > cutoff; });
    if (this._senderRateBucket.length >= CONFIG.RATE_LIMIT_COUNT) {
      return false;
    }
    this._senderRateBucket.push(now);
    return true;
  },

  /** Change nickname while staying connected. */
  async changeNick(newNick) {
    newNick = newNick.trim().slice(0, 20);
    if (newNick.length < 1) return;

    var nickCheck = this.automod.checkKeywords(newNick);
    if (!nickCheck.ok) {
      UI.addSystemMessage('That nickname is not allowed. Try another.', 'leave');
      UI.showNickOverlay();
      return;
    }

    var oldNick = this.nick;
    this.nick = newNick;
    UI.setMyNick(newNick);
    UI.hideNickOverlay();
    UI.enableInput();

    try { localStorage.setItem('jarvis-chat-nick', newNick); } catch (_) {}

    // Update presence on the primary channel
    var primary = this._primaryChannel;
    if (primary) {
      await primary.track({
        nick: this.nick,
        online_at: new Date().toISOString(),
        pubkey: Identity.pubkeyBase64 || null,
        fingerprint: Identity.fingerprint || null,
        dhPubkey: Identity.dhPubkeyBase64 || null,
      });
    }
    if (Identity.fingerprint) {
      TrustStore.check(newNick, Identity.fingerprint);
    }
    this._addSystemToChannel(this._activeChannelId, oldNick + ' is now ' + newNick, 'join');
  },

  /** Open a private DM with another user. */
  async startDM(nick, fingerprint, dhPubkey) {
    if (!dhPubkey) {
      UI.addSystemMessage('Cannot DM: user has no encryption key.', 'leave');
      return;
    }

    var channelId = this._dmChannelName(fingerprint);

    // Already viewing this DM
    if (this._activeChannelId === channelId) return;

    // Close existing DM if switching
    if (this._dmMode) this._closeDMChannel();

    // Derive shared AES key from ECDH
    try {
      this._dmKey = await Identity.deriveSharedKey(dhPubkey);
    } catch (err) {
      UI.addSystemMessage('Failed to establish secure DM channel.', 'leave');
      console.warn('ECDH derive failed:', err);
      return;
    }

    // Add to DM list if not already there
    if (!this._dmList.find(function(d) { return d.channelId === channelId; })) {
      this._dmList.push({ channelId: channelId, nick: nick, fingerprint: fingerprint, dhPubkey: dhPubkey });
    }

    // Set DM state
    this._dmMode = true;
    this._dmTargetNick = nick;
    this._dmTargetFp = fingerprint;

    // Create channel entry if needed
    if (!this._channels.has(channelId)) {
      this._channels.set(channelId, { sub: null, messages: [] });
    }
    this._unreadCounts.set(channelId, 0);

    // Subscribe to DM channel
    var sub = this.client.channel(channelId, {
      config: { broadcast: { self: false, ack: true } },
    });
    var self = this;
    sub.on('broadcast', { event: 'message' }, function(payload) {
      self._onReceiveDM(channelId, payload.payload);
    });
    sub.subscribe(function(status) {
      if (status === 'SUBSCRIBED') {
        self._addSystemToChannel(channelId, 'Secure DM with ' + nick + ' established.', 'join');
      } else if (status === 'CLOSED' || status === 'CHANNEL_ERROR') {
        self._addSystemToChannel(channelId, 'DM connection lost.', 'leave');
      }
    });
    this._channels.get(channelId).sub = sub;

    // Unsubscribe from previous non-primary channel
    var prevId = this._activeChannelId;
    if (prevId !== CONFIG.DEFAULT_CHANNEL) {
      var prevData = this._channels.get(prevId);
      if (prevData && prevData.sub) {
        this.client.removeChannel(prevData.sub);
        prevData.sub = null;
      }
    }

    // Switch view
    this._activeChannelId = channelId;
    UI.clearMessages();
    var messages = this._channels.get(channelId).messages;
    for (var i = 0; i < messages.length; i++) {
      var m = messages[i];
      if (m.type === 'system') {
        UI.addSystemMessage(m.text, m.systemType);
      } else {
        UI.addMessage(m.nick, m.text, m.time, m.color, m.verifyStatus);
      }
    }
    UI.updateChannelName('@ ' + nick);
    UI.msgInput.placeholder = 'DM to ' + nick + '...';
    UI.msgInput.focus();

    // Show DM header bar
    $('#dm-header-nick').textContent = nick;
    $('#dm-header-fp').textContent = fingerprint || '';
    $('#dm-header').classList.remove('hidden');
  },

  /** Send a DM message. */
  async sendDM(text) {
    text = text.trim();
    if (text.length === 0) return;

    var isImage = isImageDataUrl(text);
    var maxLen = isImage ? CONFIG.MAX_IMAGE_LEN : CONFIG.MAX_MSG_LEN;
    if (text.length > maxLen) return;

    if (!isImage) text = replaceEmoji(text);

    if (!this._checkSenderRateLimit()) {
      UI.showRateLimitFeedback();
      return;
    }

    if (!isImage) {
      var filterResult = this.automod.filter(text, this.userId);
      if (!filterResult.ok) {
        UI.addBlockedNotice('Your message was blocked: ' + filterResult.reason);
        return;
      }
    }

    var encrypted;
    try {
      encrypted = await Crypto.encrypt(text, this._dmKey);
    } catch (err) {
      UI.addSystemMessage('DM encryption error. Message not sent.', 'leave');
      return;
    }

    var ts = Date.now();
    var msgId = crypto.randomUUID();

    var sig = null;
    if (!this._signingDisabled) {
      try {
        var canonical = [msgId, this.userId, this.nick, ts, encrypted.iv, encrypted.ct].join('|');
        sig = await Identity.sign(canonical);
      } catch (err) {
        console.warn('Signing failed:', err);
      }
    }

    var payload = {
      id: msgId,
      userId: this.userId,
      nick: this.nick,
      ts: ts,
      iv: encrypted.iv,
      ct: encrypted.ct,
      sig: sig,
      pubkey: Identity.pubkeyBase64 || null,
      fingerprint: Identity.fingerprint || null,
    };

    var activeSub = this._channels.get(this._activeChannelId);
    if (!activeSub || !activeSub.sub) {
      UI.addSystemMessage('DM not connected.', 'leave');
      return;
    }

    await activeSub.sub.send({
      type: 'broadcast',
      event: 'message',
      payload: payload,
    });

    // Store in local history
    var dmIsImage = isImageDataUrl(text);
    var dmMsgType = dmIsImage ? 'image' : 'msg';
    var msgObj = { nick: this.nick, text: text, time: formatTime(ts), color: nickColor(this.nick), verifyStatus: 'self', type: dmMsgType };
    activeSub.messages.push(msgObj);
    if (activeSub.messages.length > 500) activeSub.messages.shift();

    if (dmIsImage) {
      UI.addImage(this.nick, text, formatTime(ts), nickColor(this.nick), 'self');
    } else {
      UI.addMessage(this.nick, text, formatTime(ts), nickColor(this.nick), 'self');
    }
    UI.msgInput.value = '';
    UI.updateCharCount(0);
  },

  /** Handle incoming DM message. */
  async _onReceiveDM(channelId, payload) {
    if (!payload || !payload.iv || !payload.ct) return;
    if (payload.userId === this.userId) return;

    var plaintext;
    try {
      plaintext = await Crypto.decrypt(payload.iv, payload.ct, this._dmKey);
    } catch (err) {
      return;
    }

    var dmRxIsImage = isImageDataUrl(plaintext);

    if (!dmRxIsImage) {
      var filterResult = this.automod.filter(plaintext, payload.userId);
      if (!filterResult.ok) return;
    }
    if (!this.automod.checkRateLimit(payload.userId, Date.now())) return;

    var nick = (typeof payload.nick === 'string')
      ? payload.nick.trim().slice(0, 20) : 'Unknown';
    var nickCheck = this.automod.checkKeywords(nick);
    if (!nickCheck.ok) nick = 'Censored';

    var verifyStatus = 'unverified';
    if (payload.sig && payload.pubkey && payload.fingerprint) {
      var canonical = [payload.id, payload.userId, payload.nick, payload.ts, payload.iv, payload.ct].join('|');
      try {
        var valid = await Identity.verify(canonical, payload.sig, payload.pubkey);
        if (valid) {
          var tofuResult = TrustStore.check(nick, payload.fingerprint);
          if (tofuResult === 'trusted' || tofuResult === 'new') {
            verifyStatus = 'verified';
          } else if (tofuResult === 'changed') {
            verifyStatus = 'key-changed';
          }
        } else {
          verifyStatus = 'invalid';
        }
      } catch (err) {
        verifyStatus = 'invalid';
      }
    }

    var time = formatTime(payload.ts || Date.now());
    var dmRxMsgType = dmRxIsImage ? 'image' : 'msg';
    var msgObj = { nick: nick, text: plaintext, time: time, color: nickColor(nick), verifyStatus: verifyStatus, type: dmRxMsgType };

    var channelData = this._channels.get(channelId);
    if (channelData) {
      channelData.messages.push(msgObj);
      if (channelData.messages.length > 500) channelData.messages.shift();
    }

    if (channelId === this._activeChannelId) {
      if (dmRxIsImage) {
        UI.addImage(nick, plaintext, time, nickColor(nick), verifyStatus);
      } else {
        UI.addMessage(nick, plaintext, time, nickColor(nick), verifyStatus);
      }
    } else {
      var current = this._unreadCounts.get(channelId) || 0;
      this._unreadCounts.set(channelId, current + 1);
    }
  },

  /** Close the DM channel subscription (internal). */
  _closeDMChannel() {
    if (!this._dmMode) return;
    var dmChannelId = this._activeChannelId;
    var dmData = this._channels.get(dmChannelId);
    if (dmData && dmData.sub) {
      this.client.removeChannel(dmData.sub);
      dmData.sub = null;
    }
    this._dmMode = false;
    this._dmKey = null;
    this._dmTargetNick = null;
    this._dmTargetFp = null;
    $('#dm-header').classList.add('hidden');
  },

  /** Close DM and return to general. */
  closeDM() {
    if (!this._dmMode) return;
    this._closeDMChannel();
    this.switchChannel(CONFIG.DEFAULT_CHANNEL);
  },

  /** Compute deterministic DM channel name from two fingerprints. */
  _dmChannelName(otherFingerprint) {
    var a = (Identity.fingerprint || '').replace(/:/g, '');
    var b = (otherFingerprint || '').replace(/:/g, '');
    var sorted = [a, b].sort();
    return CONFIG.DM_CHANNEL_PREFIX + sorted[0] + '-' + sorted[1];
  },

  /** Cleanup on page unload. */
  destroy() {
    if (this._reconnectTimeout) {
      clearTimeout(this._reconnectTimeout);
      this._reconnectTimeout = null;
    }
    if (this.automod) {
      this.automod.destroy();
    }
    if (this._channels && this.client) {
      for (var entry of this._channels) {
        var id = entry[0];
        var data = entry[1];
        if (data.sub) {
          if (id === CONFIG.DEFAULT_CHANNEL) data.sub.untrack();
          this.client.removeChannel(data.sub);
        }
      }
    }
  },
};

// =================================================================
// GLOBAL ERROR HANDLERS
// =================================================================

window.onerror = function(msg, src, line, col, err) {
  // Prevent unhandled errors from crashing the chat silently
  if (typeof UI !== 'undefined' && UI.messagesEl) {
    UI.addSystemMessage('An error occurred. Chat may be unstable.', 'leave');
  }
  return false; // Allow default browser error logging
};

window.addEventListener('unhandledrejection', function(event) {
  if (typeof UI !== 'undefined' && UI.messagesEl) {
    UI.addSystemMessage('A connection error occurred.', 'leave');
  }
});

// =================================================================
// EVENT WIRING
// =================================================================

document.addEventListener('DOMContentLoaded', () => {
  UI.init();

  // Load saved nickname or generate random default
  let savedNick = null;
  try { savedNick = localStorage.getItem('jarvis-chat-nick'); } catch (_) {}
  if (savedNick && savedNick.trim().length > 0) {
    UI.nickInput.value = savedNick.trim().slice(0, 20);
  } else {
    const randomSuffix = Math.floor(Math.random() * 9000 + 1000);
    UI.nickInput.value = 'Agent-' + randomSuffix;
  }

  // Nickname validation: alphanumeric, spaces, dashes, underscores
  const NICK_RE = /^[a-zA-Z0-9 _-]+$/;

  // Nickname entry (handles both initial join and nick change)
  const joinChat = () => {
    const nick = UI.nickInput.value.trim();
    if (nick.length < 1 || nick.length > 20) return;
    if (!NICK_RE.test(nick)) {
      UI.addSystemMessage('Nickname can only contain letters, numbers, spaces, dashes, and underscores.', 'leave');
      return;
    }
    if (Chat._primaryChannel) {
      Chat.changeNick(nick);
    } else {
      Chat.start(nick);
    }
  };

  $('#nick-join-btn').addEventListener('click', joinChat);
  UI.nickInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') joinChat();
  });

  // Click header nick to change nickname
  $('#my-nick').addEventListener('click', () => {
    if (!Chat._primaryChannel) return; // not connected yet
    UI.nickInput.value = Chat.nick;
    UI.showNickOverlay();
  });

  // Message sending (with file path interception)
  const sendMessage = () => {
    const text = UI.msgInput.value;
    if (text.trim().length === 0) return;

    // Detect file paths to images — read via IPC and send as data URL
    if (isImagePath(text.trim()) && window.jarvis && window.jarvis.ipc) {
      var path = text.trim();
      UI.msgInput.value = '';
      UI.updateCharCount(0);
      (async function() {
        try {
          var resp = await window.jarvis.ipc.request('read_file', { path: path });
          if (resp && resp.data_url) {
            var blob = await fetch(resp.data_url).then(function(r) { return r.blob(); });
            var compressed = await compressImage(blob);
            Chat.send(compressed);
          } else {
            UI.addSystemMessage('Failed to read image: ' + (resp && resp.error || 'unknown error'), 'leave');
          }
        } catch (err) {
          UI.addSystemMessage('Failed to read image file.', 'leave');
        }
      })();
      return;
    }

    Chat.send(text);
  };

  $('#send-btn').addEventListener('click', sendMessage);
  UI.msgInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      sendMessage();
    }
  });

  // Character count
  UI.msgInput.addEventListener('input', () => {
    UI.updateCharCount(UI.msgInput.value.length);
  });

  // ── Clipboard paste via Rust IPC ──
  // WKWebView doesn't fire DOM paste events for image clipboard data.
  // Instead we intercept Cmd+V, ask Rust to read the system clipboard,
  // and handle the response (image data URL or text).
  var _pendingImageDataUrl = null;

  document.addEventListener('keydown', function(e) {
    if (e.metaKey && e.key.toUpperCase() === 'V' && !e.repeat) {
      if (!window.jarvis || !window.jarvis.ipc) return;
      e.preventDefault();
      e.stopPropagation();
      window.jarvis.ipc.send('debug_event', { type: 'paste_cmd_v_intercepted' });
      window.jarvis.ipc.request('clipboard_paste', {}).then(function(resp) {
        window.jarvis.ipc.send('debug_event', {
          type: 'clipboard_paste_response',
          kind: resp.kind || 'error',
          has_data_url: !!resp.data_url,
          text_len: resp.text ? resp.text.length : 0,
          error: resp.error || null
        });
        if (resp.error) return;
        if (resp.kind === 'image' && resp.data_url) {
          // Show image paste preview (same flow as the old DOM paste handler)
          if (resp.data_url.length > CONFIG.MAX_IMAGE_LEN) {
            UI.addSystemMessage('Image too large.', 'leave');
            return;
          }
          _pendingImageDataUrl = resp.data_url;
          $('#paste-thumb').src = resp.data_url;
          var sizeKB = Math.round(resp.data_url.length * 3 / 4 / 1024);
          $('#paste-info').textContent = 'Image ready (' + sizeKB + ' KB)';
          $('#paste-preview').classList.add('show');
          UI.msgInput.focus();
        } else if (resp.kind === 'text' && resp.text) {
          // If the text looks like an image file path, load it as an image
          if (isImagePath(resp.text)) {
            window.jarvis.ipc.request('read_file', { path: resp.text.trim() }).then(function(fileResp) {
              if (fileResp && fileResp.data_url) {
                _pendingImageDataUrl = fileResp.data_url;
                $('#paste-thumb').src = fileResp.data_url;
                var sizeKB = Math.round(fileResp.data_url.length * 3 / 4 / 1024);
                $('#paste-info').textContent = 'Image ready (' + sizeKB + ' KB)';
                $('#paste-preview').classList.add('show');
                UI.msgInput.focus();
              } else {
                // Not a valid image file — just insert as text
                UI.msgInput.focus();
                document.execCommand('insertText', false, resp.text);
              }
            }).catch(function() {
              UI.msgInput.focus();
              document.execCommand('insertText', false, resp.text);
            });
          } else {
            // Plain text paste
            UI.msgInput.focus();
            document.execCommand('insertText', false, resp.text);
          }
        }
      });
    }
  }, true);

  // Paste preview: send
  $('#paste-send').addEventListener('click', function() {
    if (_pendingImageDataUrl) {
      Chat.send(_pendingImageDataUrl);
      _pendingImageDataUrl = null;
      $('#paste-preview').classList.remove('show');
    }
  });

  // Paste preview: cancel
  $('#paste-cancel').addEventListener('click', function() {
    _pendingImageDataUrl = null;
    $('#paste-preview').classList.remove('show');
  });

  // ── Image lightbox dismiss ──
  $('#image-lightbox').addEventListener('click', function() {
    this.classList.remove('open');
  });

  // ── File path detection on send ──
  var _origSendMessage = sendMessage;
  // Override sendMessage to check for file paths
  // (File path reading requires IPC — send as-is for now, Rust handler will be added)

  // Cleanup on unload
  window.addEventListener('beforeunload', () => {
    Chat.destroy();
  });

  // DM close button
  $('#dm-close-btn').addEventListener('click', function() {
    Chat.closeDM();
  });

  // Channel dropdown
  var channelDropdownOpen = false;

  $('#channel-title').addEventListener('click', function(e) {
    e.stopPropagation();
    // Close online users dropdown if open
    if (onlineDropdownOpen) {
      onlineDropdownOpen = false;
      $('#online-dropdown').classList.remove('open');
    }
    channelDropdownOpen = !channelDropdownOpen;
    var dd = $('#channel-dropdown');
    var title = $('#channel-title');
    if (channelDropdownOpen) {
      dd.classList.add('open');
      title.classList.add('open');
      renderChannelDropdown();
    } else {
      dd.classList.remove('open');
      title.classList.remove('open');
    }
  });

  document.addEventListener('click', function(e) {
    if (channelDropdownOpen
        && !e.target.closest('#channel-dropdown')
        && !e.target.closest('#channel-title')) {
      channelDropdownOpen = false;
      $('#channel-dropdown').classList.remove('open');
      $('#channel-title').classList.remove('open');
    }
  });

  function renderChannelDropdown() {
    var channelList = $('#channel-list');
    var dmListEl = $('#dm-list');
    var dmHeader = $('#dm-section-header');

    while (channelList.firstChild) channelList.removeChild(channelList.firstChild);
    while (dmListEl.firstChild) dmListEl.removeChild(dmListEl.firstChild);

    // Render channels
    CONFIG.CHANNELS.forEach(function(ch) {
      var row = document.createElement('div');
      row.className = 'channel-row';
      row.setAttribute('data-channel-id', ch.id);
      if (ch.id === Chat._activeChannelId) row.classList.add('active');

      var nameSpan = document.createElement('span');
      nameSpan.textContent = '# ' + ch.name;
      row.appendChild(nameSpan);

      var unread = Chat._unreadCounts.get(ch.id) || 0;
      if (unread > 0) {
        var badge = document.createElement('span');
        badge.className = 'unread-badge';
        badge.textContent = unread;
        row.appendChild(badge);
      }

      row.addEventListener('click', function() {
        Chat.switchChannel(ch.id);
        channelDropdownOpen = false;
        $('#channel-dropdown').classList.remove('open');
        $('#channel-title').classList.remove('open');
      });

      channelList.appendChild(row);
    });

    // Render DMs
    if (Chat._dmList && Chat._dmList.length > 0) {
      dmHeader.style.display = '';
      Chat._dmList.forEach(function(dm) {
        var row = document.createElement('div');
        row.className = 'channel-row';
        row.setAttribute('data-channel-id', dm.channelId);
        if (dm.channelId === Chat._activeChannelId) row.classList.add('active');

        var nameSpan = document.createElement('span');
        nameSpan.textContent = '@ ' + dm.nick;
        row.appendChild(nameSpan);

        var unread = Chat._unreadCounts.get(dm.channelId) || 0;
        if (unread > 0) {
          var badge = document.createElement('span');
          badge.className = 'unread-badge';
          badge.textContent = unread;
          row.appendChild(badge);
        }

        row.addEventListener('click', function() {
          Chat.startDM(dm.nick, dm.fingerprint, dm.dhPubkey);
          channelDropdownOpen = false;
          $('#channel-dropdown').classList.remove('open');
          $('#channel-title').classList.remove('open');
        });

        dmListEl.appendChild(row);
      });
    } else {
      dmHeader.style.display = 'none';
    }
  }

  // Online users dropdown
  var onlineDropdownOpen = false;

  $('#user-count').addEventListener('click', function(e) {
    e.stopPropagation();
    // Close channel dropdown if open
    if (channelDropdownOpen) {
      channelDropdownOpen = false;
      $('#channel-dropdown').classList.remove('open');
      $('#channel-title').classList.remove('open');
    }
    onlineDropdownOpen = !onlineDropdownOpen;
    var dd = $('#online-dropdown');
    if (onlineDropdownOpen) {
      dd.classList.add('open');
      renderOnlineUsers();
    } else {
      dd.classList.remove('open');
    }
  });

  document.addEventListener('click', function(e) {
    if (onlineDropdownOpen
        && !e.target.closest('#online-dropdown')
        && !e.target.closest('#user-count')) {
      onlineDropdownOpen = false;
      $('#online-dropdown').classList.remove('open');
    }
  });

  function renderOnlineUsers() {
    var list = $('#online-user-list');
    while (list.firstChild) { list.removeChild(list.firstChild); }

    if (!Chat._primaryChannel) {
      var emptyDiv = document.createElement('div');
      emptyDiv.className = 'dd-empty';
      emptyDiv.textContent = 'Not connected';
      list.appendChild(emptyDiv);
      return;
    }

    var state = Chat._primaryChannel.presenceState();
    var keys = Object.keys(state);

    if (keys.length === 0) {
      var emptyDiv = document.createElement('div');
      emptyDiv.className = 'dd-empty';
      emptyDiv.textContent = 'No users online';
      list.appendChild(emptyDiv);
      return;
    }

    keys.forEach(function(key) {
      var presences = state[key];
      if (!presences || presences.length === 0) return;
      var p = presences[0];
      var nick = (p.nick || 'Unknown').slice(0, 20);
      var fp = p.fingerprint || null;

      var row = document.createElement('div');
      row.className = 'user-row';

      var nameEl = document.createElement('div');
      nameEl.className = 'user-name';

      var dot = document.createElement('span');
      dot.className = 'online-dot';
      nameEl.appendChild(dot);

      // Verification badge
      if (fp) {
        var trustStatus = TrustStore.check(nick, fp);
        var badge = document.createElement('span');
        badge.style.marginRight = '4px';
        badge.style.fontSize = '10px';
        if (trustStatus === 'trusted' || trustStatus === 'new') {
          badge.textContent = '\u2713';
          badge.style.color = '#58a6ff';
          badge.title = 'Verified: ' + fp;
        } else if (trustStatus === 'changed') {
          badge.textContent = '\u26A0';
          badge.style.color = '#d29922';
          badge.title = 'Key changed! Was: ' + (TrustStore.getFingerprint(nick) || '?') + ' Now: ' + fp;
        }
        nameEl.appendChild(badge);
      }

      var nameText = document.createTextNode(nick);
      nameEl.appendChild(nameText);

      // Highlight current user
      if (key === Chat.userId) {
        nameEl.style.opacity = '1';
        nameEl.style.fontWeight = 'bold';
      }

      row.appendChild(nameEl);

      // DM button (only for other users with ECDH key)
      if (key !== Chat.userId && fp && Identity.fingerprint && p.dhPubkey) {
        var dmBtn = document.createElement('button');
        dmBtn.className = 'dm-btn';
        dmBtn.textContent = 'DM';
        dmBtn.title = 'Direct message ' + nick;
        var _dhPub = p.dhPubkey;
        dmBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          Chat.startDM(nick, fp, _dhPub);
          $('#online-dropdown').classList.remove('open');
          onlineDropdownOpen = false;
        });
        row.appendChild(dmBtn);
      }

      list.appendChild(row);
    });
  }

  // Focus nickname input only if this pane has focus
  // (avoids stealing focus from terminal panes on startup)
  if (window.jarvis && window.jarvis.ipc) {
    window.jarvis.ipc.on('focus_changed', function(payload) {
      if (payload && payload.focused && UI.nickOverlay && !UI.nickOverlay.classList.contains('hidden')) {
        UI.nickInput.focus();
      } else if (payload && payload.focused && UI.msgInput && !UI.msgInput.disabled) {
        UI.msgInput.focus();
      }
    });
  }


});
</script>
</body>
</html>
