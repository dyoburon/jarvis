# PLAN: Livechat Feature — Full Wiring + Metal UI
Date: 2026-02-27
Status: Draft

## REQUIRED SKILLS — LOAD BEFORE PROCEEDING
skill({ name: "modular" })
skill({ name: "orion-code-standards" })
skill({ name: "testing-strategy" })
skill({ name: "websockets" })

## Overview
Wire the livechat feature end-to-end: add `ToggleChat` action + keybind, port the Metal
app's chat HTML UI, store incoming messages in `ChatHistory`, enforce auto-moderation,
fix `chrono_now()` to emit ISO 8601, and connect everything through the existing
Supabase Realtime transport.

## Context
The livechat feature has four complete layers (config, protocol, transport, storage)
but they are completely disconnected. Incoming chat messages are logged and discarded.
There is no action, keybind, or UI to open chat. The `chrono_now()` function returns
epoch millis instead of ISO 8601. Auto-moderation rules exist in config but are never
enforced.

## Scope
- **In scope**: Action enum, keybind, config, chat HTML UI (ported from Metal), message
  storage wiring, auto-mod enforcement, chrono_now fix, tests
- **Out of scope**: Voice chat, screen share, pair programming, custom emoji, file
  uploads, message persistence to disk/DB, user authentication flow (uses existing
  Supabase identity)

## Implementation Phases

### Phase 1: Fix `chrono_now()` + add chrono dep to jarvis-social
- **Files**: `crates/jarvis-social/Cargo.toml`, `crates/jarvis-social/src/presence.rs`
- **Steps**:
  1. Add `chrono = { workspace = true }` to jarvis-social's Cargo.toml
  2. Replace `chrono_now()` in presence.rs to use `chrono::Utc::now().to_rfc3339()`
- **Test**: Unit test that `chrono_now()` output parses as valid RFC 3339
- **Pass criteria**: `cargo test -p jarvis-social` passes

### Phase 2: Add `ToggleChat` + `SendChatMessage` actions
- **Files**: `crates/jarvis-common/src/actions.rs`
- **Steps**:
  1. Add `ToggleChat` variant to `Action` enum (UI section)
  2. Add `SendChatMessage { channel: String, content: String }` variant
  3. Add labels: "Toggle Chat", "Send Chat Message"
  4. Add `ToggleChat` to `palette_actions()`
- **Test**: Existing tests pass + new serde roundtrip test for ToggleChat
- **Pass criteria**: `cargo test -p jarvis-common` passes

### Phase 3: Add `open_chat` keybind to config + registry
- **Files**: `crates/jarvis-config/src/schema.rs`, `crates/jarvis-config/src/keybinds.rs`,
  `crates/jarvis-platform/src/input.rs`
- **Steps**:
  1. Add `open_chat: String` field to `KeybindConfig` with default `"Cmd+L"`
  2. Add `("open_chat", &config.open_chat)` to `all_keybinds()`
  3. Add `(&config.open_chat, Action::ToggleChat)` to `KeybindRegistry::from_config()`
- **Test**: Keybind count test updated to 18, no-duplicate test still passes,
  registry lookup for `Cmd+L` returns `ToggleChat`
- **Pass criteria**: `cargo test -p jarvis-config -p jarvis-platform` passes

### Phase 4: Add auto-moderation enforcement to `send_chat`
- **Files**: `crates/jarvis-social/src/presence.rs`, `crates/jarvis-social/src/chat.rs`
- **Steps**:
  1. Add `AutoModConfig` parameter to `PresenceClient::new()` or a new
     `validate_chat_message()` function
  2. In `send_chat()`: check message length against `max_message_length`, reject empty
  3. Add rate limiting: track last N send timestamps, reject if > `rate_limit` per
     10 seconds
  4. Return `Result<(), ChatError>` from `send_chat()` instead of silent ignore
- **Test**: Unit tests for message too long, empty message, rate limit exceeded
- **Pass criteria**: `cargo test -p jarvis-social` passes

### Phase 5: Wire ChatHistory into app_state
- **Files**: `crates/jarvis-app/src/app_state.rs`
- **Steps**:
  1. Add `chat_history: ChatHistory` field to `JarvisApp`
  2. Add `chat_visible: bool` field
  3. In `poll_presence()` ChatMessage handler: convert `PresenceEvent::ChatMessage`
     to `chat::ChatMessage` and push into `chat_history`
  4. In action dispatch: handle `Action::ToggleChat` to flip `chat_visible`
  5. Add notification for incoming chat messages when chat is closed
- **Test**: Integration-style test that a PresenceEvent::ChatMessage gets stored
- **Pass criteria**: `cargo test -p jarvis-app` passes

### Phase 6: Create chat HTML template
- **Files**: New `crates/jarvis-webview/src/chat_html.rs`
- **Steps**:
  1. Create `chat_html.rs` with `pub fn build_chat_html(title: &str) -> String`
  2. Port the Metal app's `ChatWebViewHTML.swift` design:
     - Title bar with channel name + close button
     - Messages area with scrollable container + auto-scroll
     - Input bar with textarea + Enter to send
     - Status bar showing online count
     - CSS theme using CSS variables (dark theme matching Metal look)
  3. Adapt JS to use Jarvis IPC bridge (`window.jarvis.ipc.send()`) instead of
     `window.webkit.messageHandlers`
  4. Message types: `chat_msg` (speaker + display_name + content), `status`,
     `online_count`
  5. Add IPC handler: `chat_input` → sends typed message back to Rust
  6. Register module in `crates/jarvis-webview/src/lib.rs`
- **Test**: Unit test that `build_chat_html("general")` contains expected elements
  (title, messages div, input, IPC bridge)
- **Pass criteria**: `cargo test -p jarvis-webview` passes

### Phase 7: Wire chat UI into app_state lifecycle
- **Files**: `crates/jarvis-app/src/app_state.rs`
- **Steps**:
  1. On `Action::ToggleChat`: if chat not visible, create WebView with chat HTML
     via `WebViewRegistry`; if visible, destroy it
  2. On incoming `ChatMessage`: if chat WebView exists, evaluate JS to append message
  3. On `IpcMessage` from chat WebView: parse as chat input, call
     `presence_client.send_chat()`
  4. On chat close (IPC `__close_panel__`): set `chat_visible = false`, destroy WebView
- **Test**: Verify action dispatch toggles chat_visible flag
- **Pass criteria**: `cargo test -p jarvis-app` passes, `cargo build` succeeds

## Risks & Mitigations
| Risk | Impact | Mitigation |
|------|--------|------------|
| Keybind `Cmd+L` conflicts with user custom binds | Low | Duplicate validation catches it at config load |
| chrono_now format change breaks existing presence payloads | Medium | Both sides updated together in Phase 1; no persisted data |
| Chat spam via IPC | Medium | Auto-mod enforced in Phase 4 before broadcast |
| WebView creation fails (wry error) | Low | Existing error handling in WebViewRegistry; log + show notification |

## Rollback Plan
- Feature is gated by `livechat.enabled` config (default true)
- All changes are additive — no existing behavior modified except chrono_now (Phase 1)
- Revert branch if needed; no data migrations to undo

## Success Criteria
- [ ] `Cmd+L` opens chat panel with Metal-style UI
- [ ] Incoming Supabase Realtime chat messages appear in the panel
- [ ] Typing + Enter sends a message via Supabase Realtime broadcast
- [ ] Messages stored in ChatHistory (bounded ring buffer)
- [ ] Auto-mod rejects messages that are too long or exceed rate limit
- [ ] `chrono_now()` returns ISO 8601 timestamps
- [ ] All tests pass: `cargo test --workspace`
- [ ] `cargo build` succeeds with no warnings

## Approval
- [ ] User approved this plan
