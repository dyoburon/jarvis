<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>JARVIS Draw</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0a0a;
  font-family: 'Courier New', monospace;
  overflow: hidden;
  user-select: none;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

#toolbar {
  display: flex;
  align-items: center;
  gap: 6px;
  padding: 6px 10px;
  background: #0d1117;
  border-bottom: 1px solid #1a2a3a;
  flex-shrink: 0;
  flex-wrap: wrap;
}

#toolbar .group {
  display: flex;
  gap: 3px;
  padding: 0 6px;
  border-right: 1px solid #1a2a3a;
}

#toolbar .group:last-child { border-right: none; }

.tool-btn {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: 1px solid #2a4a5a;
  color: #00e5ff;
  font-size: 16px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.15s;
}

.tool-btn:hover {
  background: #1a2a3a;
  border-color: #00e5ff;
}

.tool-btn.active {
  background: #00e5ff;
  color: #0a0a0a;
  border-color: #00e5ff;
  box-shadow: 0 0 10px rgba(0, 229, 255, 0.3);
}

.tool-btn svg {
  width: 18px;
  height: 18px;
  fill: none;
  stroke: currentColor;
  stroke-width: 2;
  stroke-linecap: round;
  stroke-linejoin: round;
}

.color-btn {
  width: 22px;
  height: 22px;
  border-radius: 50%;
  border: 2px solid #333;
  cursor: pointer;
  transition: all 0.15s;
}

.color-btn:hover { transform: scale(1.15); }
.color-btn.active { border-color: #fff; box-shadow: 0 0 8px rgba(255,255,255,0.3); }

.size-btn {
  width: 28px;
  height: 28px;
  display: flex;
  align-items: center;
  justify-content: center;
  background: transparent;
  border: 1px solid #2a4a5a;
  color: #888;
  font-size: 10px;
  cursor: pointer;
  border-radius: 4px;
}

.size-btn:hover { border-color: #00e5ff; color: #00e5ff; }
.size-btn.active { background: #1a2a3a; border-color: #00e5ff; color: #00e5ff; }

.action-btn {
  height: 28px;
  padding: 0 10px;
  background: transparent;
  border: 1px solid #2a4a5a;
  color: #888;
  font-family: 'Courier New', monospace;
  font-size: 10px;
  cursor: pointer;
  border-radius: 4px;
  transition: all 0.15s;
}

.action-btn:hover { border-color: #00e5ff; color: #00e5ff; }
.action-btn.danger:hover { border-color: #ff0040; color: #ff0040; }

#canvas-wrap {
  flex: 1;
  position: relative;
  overflow: hidden;
  cursor: crosshair;
}

canvas {
  position: absolute;
  top: 0;
  left: 0;
}

#text-input {
  position: absolute;
  background: transparent;
  border: 1px dashed #00e5ff;
  color: #00e5ff;
  font-family: 'Courier New', monospace;
  font-size: 16px;
  padding: 2px 4px;
  outline: none;
  display: none;
  min-width: 60px;
  z-index: 10;
}

.label {
  color: #555;
  font-size: 10px;
  margin-right: 2px;
}
</style>
</head>
<body>
<div id="toolbar">
  <div class="group">
    <span class="label">TOOLS</span>
    <button class="tool-btn active" data-tool="pen" title="Pen (P)">
      <svg viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"/><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"/><path d="M2 2l7.586 7.586"/><circle cx="11" cy="11" r="2"/></svg>
    </button>
    <button class="tool-btn" data-tool="line" title="Line (L)">
      <svg viewBox="0 0 24 24"><line x1="5" y1="19" x2="19" y2="5"/></svg>
    </button>
    <button class="tool-btn" data-tool="rect" title="Rectangle (R)">
      <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2"/></svg>
    </button>
    <button class="tool-btn" data-tool="ellipse" title="Ellipse (E)">
      <svg viewBox="0 0 24 24"><ellipse cx="12" cy="12" rx="10" ry="7"/></svg>
    </button>
    <button class="tool-btn" data-tool="arrow" title="Arrow (A)">
      <svg viewBox="0 0 24 24"><line x1="5" y1="19" x2="19" y2="5"/><polyline points="12 5 19 5 19 12"/></svg>
    </button>
    <button class="tool-btn" data-tool="text" title="Text (T)">
      <svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"/><line x1="12" y1="4" x2="12" y2="20"/><line x1="8" y1="20" x2="16" y2="20"/></svg>
    </button>
    <button class="tool-btn" data-tool="eraser" title="Eraser (X)">
      <svg viewBox="0 0 24 24"><path d="M20 20H7L3 16l9-9 8 8-4 4"/><line x1="6" y1="11" x2="13" y2="18"/></svg>
    </button>
  </div>

  <div class="group">
    <span class="label">SIZE</span>
    <button class="size-btn" data-size="2">S</button>
    <button class="size-btn active" data-size="4">M</button>
    <button class="size-btn" data-size="8">L</button>
    <button class="size-btn" data-size="16">XL</button>
  </div>

  <div class="group" id="color-group">
    <span class="label">COLOR</span>
  </div>

  <div class="group">
    <button class="action-btn" id="btn-undo" title="Undo (Ctrl+Z)">UNDO</button>
    <button class="action-btn" id="btn-redo" title="Redo (Ctrl+Y)">REDO</button>
    <button class="action-btn danger" id="btn-clear" title="Clear All">CLEAR</button>
    <button class="action-btn" id="btn-save" title="Save PNG">SAVE</button>
  </div>
</div>

<div id="canvas-wrap">
  <canvas id="canvas"></canvas>
  <input type="text" id="text-input" />
</div>

<script>
const COLORS = [
  '#00e5ff', '#ff6b00', '#ff00ff', '#ffdd00',
  '#00ff88', '#ff0040', '#ffffff', '#888888',
];

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
const wrap = document.getElementById('canvas-wrap');
const textInput = document.getElementById('text-input');
const colorGroup = document.getElementById('color-group');

let currentTool = 'pen';
let currentColor = COLORS[0];
let currentSize = 4;

// History for undo/redo
let history = [];
let redoStack = [];
let maxHistory = 50;

// Drawing state
let drawing = false;
let startX, startY;
let currentPath = [];

// Pan/zoom state
let offsetX = 0, offsetY = 0;
let scale = 1;
let panning = false;
let panStartX, panStartY;

// Elements drawn
let elements = [];

function resize() {
  const rect = wrap.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  redraw();
}

window.addEventListener('resize', resize);

// Color buttons
COLORS.forEach((c, i) => {
  const btn = document.createElement('button');
  btn.className = 'color-btn' + (i === 0 ? ' active' : '');
  btn.style.background = c;
  btn.addEventListener('click', () => {
    document.querySelector('.color-btn.active')?.classList.remove('active');
    btn.classList.add('active');
    currentColor = c;
  });
  colorGroup.appendChild(btn);
});

// Tool buttons
document.querySelectorAll('.tool-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.tool-btn.active')?.classList.remove('active');
    btn.classList.add('active');
    currentTool = btn.dataset.tool;
    wrap.style.cursor = currentTool === 'text' ? 'text' : currentTool === 'eraser' ? 'cell' : 'crosshair';
  });
});

// Size buttons
document.querySelectorAll('.size-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelector('.size-btn.active')?.classList.remove('active');
    btn.classList.add('active');
    currentSize = +btn.dataset.size;
  });
});

// Actions
document.getElementById('btn-undo').addEventListener('click', undo);
document.getElementById('btn-redo').addEventListener('click', redo);
document.getElementById('btn-clear').addEventListener('click', () => {
  if (elements.length === 0) return;
  saveHistory();
  elements = [];
  redraw();
});
document.getElementById('btn-save').addEventListener('click', savePNG);

function saveHistory() {
  history.push(JSON.stringify(elements));
  if (history.length > maxHistory) history.shift();
  redoStack = [];
}

function undo() {
  if (history.length === 0) return;
  redoStack.push(JSON.stringify(elements));
  elements = JSON.parse(history.pop());
  redraw();
}

function redo() {
  if (redoStack.length === 0) return;
  history.push(JSON.stringify(elements));
  elements = JSON.parse(redoStack.pop());
  redraw();
}

function savePNG() {
  const link = document.createElement('a');
  link.download = 'jarvis-drawing.png';
  link.href = canvas.toDataURL('image/png');
  link.click();
}

// Transform helpers
function screenToWorld(sx, sy) {
  return [(sx - offsetX) / scale, (sy - offsetY) / scale];
}

// Drawing
function getPos(e) {
  const rect = wrap.getBoundingClientRect();
  return screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
}

canvas.addEventListener('mousedown', e => {
  if (e.button === 1 || (e.button === 0 && e.altKey)) {
    // Middle click or alt+click: pan
    panning = true;
    panStartX = e.clientX - offsetX;
    panStartY = e.clientY - offsetY;
    wrap.style.cursor = 'grabbing';
    return;
  }

  if (e.button !== 0) return;
  const [wx, wy] = getPos(e);

  if (currentTool === 'text') {
    const rect = wrap.getBoundingClientRect();
    textInput.style.left = (e.clientX - rect.left) + 'px';
    textInput.style.top = (e.clientY - rect.top) + 'px';
    textInput.style.color = currentColor;
    textInput.style.fontSize = Math.max(14, currentSize * 4) + 'px';
    textInput.style.display = 'block';
    textInput.value = '';
    textInput.focus();
    textInput.onkeydown = ev => {
      if (ev.key === 'Enter') {
        if (textInput.value.trim()) {
          saveHistory();
          elements.push({
            type: 'text',
            x: wx, y: wy,
            text: textInput.value,
            color: currentColor,
            size: Math.max(14, currentSize * 4),
          });
          redraw();
        }
        textInput.style.display = 'none';
        textInput.onkeydown = null;
      } else if (ev.key === 'Escape') {
        textInput.style.display = 'none';
        textInput.onkeydown = null;
      }
    };
    return;
  }

  if (currentTool === 'eraser') {
    // Erase elements near click
    eraseAt(wx, wy);
    drawing = true;
    return;
  }

  drawing = true;
  startX = wx;
  startY = wy;

  if (currentTool === 'pen') {
    currentPath = [{ x: wx, y: wy }];
  }
});

canvas.addEventListener('mousemove', e => {
  if (panning) {
    offsetX = e.clientX - panStartX;
    offsetY = e.clientY - panStartY;
    redraw();
    return;
  }

  if (!drawing) return;
  const [wx, wy] = getPos(e);

  if (currentTool === 'eraser') {
    eraseAt(wx, wy);
    return;
  }

  if (currentTool === 'pen') {
    currentPath.push({ x: wx, y: wy });
    redraw();
    drawPenPreview();
    return;
  }

  // Shape preview
  redraw();
  drawShapePreview(wx, wy);
});

canvas.addEventListener('mouseup', e => {
  if (panning) {
    panning = false;
    wrap.style.cursor = currentTool === 'text' ? 'text' : currentTool === 'eraser' ? 'cell' : 'crosshair';
    return;
  }

  if (!drawing) return;
  drawing = false;

  const [wx, wy] = getPos(e);

  if (currentTool === 'eraser') return;

  saveHistory();

  if (currentTool === 'pen') {
    if (currentPath.length > 1) {
      elements.push({
        type: 'pen',
        points: [...currentPath],
        color: currentColor,
        size: currentSize,
      });
    }
    currentPath = [];
  } else if (currentTool === 'line') {
    elements.push({
      type: 'line',
      x1: startX, y1: startY, x2: wx, y2: wy,
      color: currentColor, size: currentSize,
    });
  } else if (currentTool === 'arrow') {
    elements.push({
      type: 'arrow',
      x1: startX, y1: startY, x2: wx, y2: wy,
      color: currentColor, size: currentSize,
    });
  } else if (currentTool === 'rect') {
    elements.push({
      type: 'rect',
      x: Math.min(startX, wx), y: Math.min(startY, wy),
      w: Math.abs(wx - startX), h: Math.abs(wy - startY),
      color: currentColor, size: currentSize,
    });
  } else if (currentTool === 'ellipse') {
    const cx = (startX + wx) / 2, cy = (startY + wy) / 2;
    const rx = Math.abs(wx - startX) / 2, ry = Math.abs(wy - startY) / 2;
    elements.push({
      type: 'ellipse',
      cx, cy, rx, ry,
      color: currentColor, size: currentSize,
    });
  }

  redraw();
});

// Mouse wheel zoom
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  const rect = wrap.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const oldScale = scale;
  const delta = e.deltaY > 0 ? 0.9 : 1.1;
  scale = Math.max(0.1, Math.min(10, scale * delta));

  // Zoom toward cursor
  offsetX = mx - (mx - offsetX) * (scale / oldScale);
  offsetY = my - (my - offsetY) * (scale / oldScale);

  redraw();
}, { passive: false });

function eraseAt(wx, wy) {
  const eraserR = currentSize * 3;
  const before = elements.length;
  elements = elements.filter(el => {
    if (el.type === 'pen') {
      return !el.points.some(p => dist(p.x, p.y, wx, wy) < eraserR);
    }
    if (el.type === 'line' || el.type === 'arrow') {
      return distToSegment(wx, wy, el.x1, el.y1, el.x2, el.y2) > eraserR;
    }
    if (el.type === 'rect') {
      return !(wx > el.x - eraserR && wx < el.x + el.w + eraserR &&
               wy > el.y - eraserR && wy < el.y + el.h + eraserR);
    }
    if (el.type === 'ellipse') {
      const dx = (wx - el.cx) / (el.rx || 1);
      const dy = (wy - el.cy) / (el.ry || 1);
      return dx * dx + dy * dy > 1.5;
    }
    if (el.type === 'text') {
      return dist(el.x, el.y, wx, wy) > eraserR * 2;
    }
    return true;
  });
  if (elements.length !== before) {
    saveHistory();
    redraw();
  }
}

function dist(x1, y1, x2, y2) {
  return Math.sqrt((x2-x1)**2 + (y2-y1)**2);
}

function distToSegment(px, py, x1, y1, x2, y2) {
  const dx = x2 - x1, dy = y2 - y1;
  const lenSq = dx*dx + dy*dy;
  if (lenSq === 0) return dist(px, py, x1, y1);
  let t = ((px-x1)*dx + (py-y1)*dy) / lenSq;
  t = Math.max(0, Math.min(1, t));
  return dist(px, py, x1 + t*dx, y1 + t*dy);
}

function applyTransform() {
  ctx.setTransform(scale, 0, 0, scale, offsetX, offsetY);
}

function drawElement(el) {
  ctx.strokeStyle = el.color;
  ctx.fillStyle = el.color;
  ctx.lineWidth = el.size / scale;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';

  if (el.type === 'pen') {
    if (el.points.length < 2) return;
    ctx.beginPath();
    ctx.moveTo(el.points[0].x, el.points[0].y);
    for (let i = 1; i < el.points.length; i++) {
      ctx.lineTo(el.points[i].x, el.points[i].y);
    }
    ctx.stroke();
  } else if (el.type === 'line') {
    ctx.beginPath();
    ctx.moveTo(el.x1, el.y1);
    ctx.lineTo(el.x2, el.y2);
    ctx.stroke();
  } else if (el.type === 'arrow') {
    ctx.beginPath();
    ctx.moveTo(el.x1, el.y1);
    ctx.lineTo(el.x2, el.y2);
    ctx.stroke();
    // Arrowhead
    const angle = Math.atan2(el.y2 - el.y1, el.x2 - el.x1);
    const headLen = 12 + el.size;
    ctx.beginPath();
    ctx.moveTo(el.x2, el.y2);
    ctx.lineTo(el.x2 - headLen * Math.cos(angle - 0.4), el.y2 - headLen * Math.sin(angle - 0.4));
    ctx.moveTo(el.x2, el.y2);
    ctx.lineTo(el.x2 - headLen * Math.cos(angle + 0.4), el.y2 - headLen * Math.sin(angle + 0.4));
    ctx.stroke();
  } else if (el.type === 'rect') {
    ctx.beginPath();
    ctx.rect(el.x, el.y, el.w, el.h);
    ctx.stroke();
  } else if (el.type === 'ellipse') {
    ctx.beginPath();
    ctx.ellipse(el.cx, el.cy, Math.max(1, el.rx), Math.max(1, el.ry), 0, 0, Math.PI * 2);
    ctx.stroke();
  } else if (el.type === 'text') {
    ctx.font = `${el.size}px Courier New`;
    ctx.textBaseline = 'top';
    ctx.fillText(el.text, el.x, el.y);
  }
}

function drawGrid() {
  // Subtle dot grid
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  const spacing = 30 * scale;
  if (spacing < 8) { ctx.restore(); return; }
  const ox = offsetX % spacing;
  const oy = offsetY % spacing;
  ctx.fillStyle = '#1a1a2a';
  for (let x = ox; x < canvas.width; x += spacing) {
    for (let y = oy; y < canvas.height; y += spacing) {
      ctx.fillRect(x, y, 1, 1);
    }
  }
  ctx.restore();
}

function redraw() {
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = '#0a0a0a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  drawGrid();
  applyTransform();

  elements.forEach(drawElement);

  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function drawPenPreview() {
  if (currentPath.length < 2) return;
  applyTransform();
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = currentSize / scale;
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.beginPath();
  ctx.moveTo(currentPath[0].x, currentPath[0].y);
  for (let i = 1; i < currentPath.length; i++) {
    ctx.lineTo(currentPath[i].x, currentPath[i].y);
  }
  ctx.stroke();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

function drawShapePreview(wx, wy) {
  applyTransform();
  ctx.strokeStyle = currentColor;
  ctx.lineWidth = currentSize / scale;
  ctx.lineCap = 'round';
  ctx.setLineDash([6 / scale, 4 / scale]);

  if (currentTool === 'line') {
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(wx, wy);
    ctx.stroke();
  } else if (currentTool === 'arrow') {
    ctx.beginPath();
    ctx.moveTo(startX, startY);
    ctx.lineTo(wx, wy);
    ctx.stroke();
    ctx.setLineDash([]);
    const angle = Math.atan2(wy - startY, wx - startX);
    const headLen = 12 + currentSize;
    ctx.beginPath();
    ctx.moveTo(wx, wy);
    ctx.lineTo(wx - headLen * Math.cos(angle - 0.4), wy - headLen * Math.sin(angle - 0.4));
    ctx.moveTo(wx, wy);
    ctx.lineTo(wx - headLen * Math.cos(angle + 0.4), wy - headLen * Math.sin(angle + 0.4));
    ctx.stroke();
  } else if (currentTool === 'rect') {
    ctx.beginPath();
    ctx.rect(Math.min(startX, wx), Math.min(startY, wy), Math.abs(wx - startX), Math.abs(wy - startY));
    ctx.stroke();
  } else if (currentTool === 'ellipse') {
    const cx = (startX + wx) / 2, cy = (startY + wy) / 2;
    const rx = Math.abs(wx - startX) / 2, ry = Math.abs(wy - startY) / 2;
    ctx.beginPath();
    ctx.ellipse(cx, cy, Math.max(1, rx), Math.max(1, ry), 0, 0, Math.PI * 2);
    ctx.stroke();
  }

  ctx.setLineDash([]);
  ctx.setTransform(1, 0, 0, 1, 0, 0);
}

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (textInput.style.display !== 'none') return;

  if ((e.ctrlKey || e.metaKey) && e.key === 'z') { e.preventDefault(); undo(); return; }
  if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.shiftKey && e.key === 'z'))) { e.preventDefault(); redo(); return; }
  if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); savePNG(); return; }

  const keyMap = { p: 'pen', l: 'line', r: 'rect', e: 'ellipse', a: 'arrow', t: 'text', x: 'eraser' };
  if (keyMap[e.key]) {
    document.querySelector('.tool-btn.active')?.classList.remove('active');
    document.querySelector(`[data-tool="${keyMap[e.key]}"]`)?.classList.add('active');
    currentTool = keyMap[e.key];
    wrap.style.cursor = currentTool === 'text' ? 'text' : currentTool === 'eraser' ? 'cell' : 'crosshair';
  }

  // Number keys for size
  if (e.key === '1') setSize(2);
  if (e.key === '2') setSize(4);
  if (e.key === '3') setSize(8);
  if (e.key === '4') setSize(16);
});

function setSize(s) {
  currentSize = s;
  document.querySelector('.size-btn.active')?.classList.remove('active');
  document.querySelector(`[data-size="${s}"]`)?.classList.add('active');
}

// Prevent context menu
canvas.addEventListener('contextmenu', e => e.preventDefault());

// Touch support
canvas.addEventListener('touchstart', e => {
  e.preventDefault();
  const touch = e.touches[0];
  canvas.dispatchEvent(new MouseEvent('mousedown', {
    clientX: touch.clientX, clientY: touch.clientY, button: 0,
  }));
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  e.preventDefault();
  const touch = e.touches[0];
  canvas.dispatchEvent(new MouseEvent('mousemove', {
    clientX: touch.clientX, clientY: touch.clientY,
  }));
}, { passive: false });

canvas.addEventListener('touchend', e => {
  e.preventDefault();
  canvas.dispatchEvent(new MouseEvent('mouseup', { button: 0 }));
}, { passive: false });

resize();
</script>
</body>
</html>
